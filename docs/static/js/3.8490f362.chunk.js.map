{"version":3,"sources":["../../../src/cubing/puzzle-geometry/Perm.ts","../../../src/cubing/puzzle-geometry/PermOriSet.ts","../../../src/cubing/puzzle-geometry/FaceNameSwizzler.ts","../../../src/cubing/puzzle-geometry/NotationMapper.ts","../../../src/cubing/puzzle-geometry/PGPuzzles.ts","../../../src/cubing/puzzle-geometry/Quat.ts","../../../src/cubing/puzzle-geometry/PlatonicGenerator.ts","../../../src/cubing/puzzle-geometry/PuzzleGeometry.ts","../../../src/cubing/puzzle-geometry/SchreierSims.ts"],"names":["zeroCache","iotaCache","zeros","n","c","Array","i","iota","lcm","a","b","t","m","gcd","this","length","p","join","p2","Perm","cyc","seen","incyc","j","push","r","cs","size","mod","factorial","Math","pow","orbitnames","orbitdefs","solved","movenames","moveops","mp","orbits","toKpuzzle","name","forTwisty","result","o","toKsolveVS","isIdentity","toKsolve","start","numPieces","orientations","moves","transformToKPuzzle","startPieces","neworbitnames","neworbitdefs","newsolved","newmoveops","om","du","changed","k","perm","ori","union","keepori","duo","find","nontriv","multiple","h","no","on","nv","remapVS","remap","killOri","OrbitsDef","map","_","pool","floor","random","ri","rj","rm","mul","s","reassemblySize","orimod","newPerm","newOri","done","v","toPerm","order","nextNew","reassign","ov","newori","kcache","permutation","orientation","newOrbits","inv","equal","perms","identicalPieces","Transformation","internalMul","e","internalInv","Orbit","VisibleState","heads","ah","bh","facenames","gripnames_arg","prefixFree","gripnames","startsWith","names","at","currentMatch","substr","Error","list","sep","userinput","longname","e1","splitByFaceNames","e2","found","endsWith","slice","upperCaseGrip","toUpperCase","g","spinmatch","move","negate","family","slices","grip","innerLayer","outerLayer","effectiveAmount","internalNames","externalNames","suffix","upper","isLowerCase","joinByFaceIndices","toLowerCase","ngrip","convertString","convert","child","abs","notationToInternal","notationToExternal","fam","sw","substring","PGPuzzles","eps","centermassface","face","sum","smul","solvethreeplanes","p1","p3","planes","intersect3","dt","d","left","right","q","cutface","FaceTree","split","arr","leftfirst","collect","Quat","hypot","sqrt","dot","normalize","acos","a00","a01","a02","a10","a11","a12","a20","a21","a22","invrot","ab","ac","ad","cross","sub","len","orthogonal","rotatepoint","cubie","rotateface","det","det3x3","x","side","inout","nface","kk","vk","pt","faces","nfaces","dist","uniqueplanes","planerot","rotateplane","wasseen","getface","NEW_FACE_NAMES","useNewFaceNames","use","findelement","getpuzzles","getpuzzle","puzzleName","parsedesc","filter","Boolean","getPuzzleGeometryByDesc","desc","options","shape","cuts","pg","concat","allstickers","genperms","getPuzzleGeometryByName","getmovename","geo","bits","inverted","movenameFamily","movenamePrefix","String","toCoords","maxdist","toFaceCoords","trimEdges","tr","iter","pi","ni","A","B","good","optionlist","JSON","parse","args","cmovesbyslice","verbose","allmoves","cornersets","centersets","edgesets","graycorners","graycenters","grayedges","killorientation","optimize","scramble","fixPiece","orientCenters","duplicatedFaces","duplicatedCubies","fixedCubie","net","colors","faceorder","faceprecedence","notationMapper","addNotationMapper","setReidOrder","asboolean","outerblockmoves","vertexmoves","addrotations","movelist","asstructured","puzzleOrientation","puzzleOrientations","console","log","header","create","moveplanes","moveplanes2","cubies","s5","cube","octahedron","dx","dy","dd","ang","PI","cos","sin","icosahedron","d36","dodecahedron","rotations","ns","negns","closure","baseplane","baseplanerot","baseplanes","basefacecount","4","6","8","12","20","F","D","L","R","U","BB","BL","BR","C","E","BF","I","G","S","H","J","K","M","O","P","N","Q","baseface","zero","facenormal","makenormal","edgenormal","vertexnormal","boundary","edgedistance","vertexdistance","cutplanes","intersects","sawface","sawedge","sawvertex","normal","distance","makecut","Number","basefaces","faceplanes","vertexnames","edgenames","edgesperface","jj","searchaddelement","otherfaces","facelist","el","facenametoindex","faceindextoname","fi","ii","fn2","of","faceplane","facename","jjj","midpoint2","swizzler","c1","c2","cornerfaces","st","geonormals","geonormalnames","setGripNames","sameplane","ft","tar","rval","stickersperface","shortedge","keyface2","cm","moveplanesets","dv","key","facelisthash","face2","facecentermass","facen","edgen","targvec","edgen2","plane","x0","olen","y0","delta","cosr","sinr","x1","y1","off","rots","expandfaces","moveplanenormals","qnormal","normalizeplane","goodnormal","sort","sizes","moverotations","angle","reverse","sizes2","movesetorders","movesetgeos","gtype","p0","neg","pos","cubiehash","cubiekey","cubiekeys","keyface","suff","s2","Object","keys","cmall","looplimit","u","mini","minf","findface","temp","getfaceindex","ocubie","ofacelist","facetocubies","typenames","cubiesetnames","cubietypecounts","orbitoris","cubiesetnum","cubiesetnums","cubieordnums","cubieords","cubievaluemap","getcolorkey","cubienum","cubiesetcubies","cubiekeymap","cubievalueid","facecnt","typectr","typename","queue","qg","cind","cubiecolorkey","tq","findface2","reidorder","reidmap","mask","charCodeAt","mv","newmv","unswizzle","re","RegExp","match","loslice","hislice","parseInt","amountstr","amount","bm","fullrotation","msi","geoname","firstgrip","parseMove","stringToBlockMove","moveplaneset","slicenum","slicecnts","bhi","axiscmoves","sc","cubiedone","ocm","fi2","cm2","face1","face0","parsedmovelist","parsemove","__","parsedmove","msg","dep","trim","newr","skipbyori","set","comment","os","getOrbitsDef","mvs","movename","toGap","ip","fortwisty","od","moveNotation","moverange","setmoves","movesetorder","moveorbits","oris","slicecmoves","mperm","setnum","inc","oinc","lastId","mulScalar","setnames","setdefs","moveset","getmovesets","allbits","skipcubie","movesetgeo","movebits","mna","getMoveFromBits","ksolvemovenames","disp","orders","commutes","permA","permB","curlev","nextlev","uniq","sti","cnt","nst","desiredRotation","feature1name","direction1","feature2name","direction2","feature1","feature2","feature1geoname","feature2geoname","gn","r1","pointrotation","unproject","rotDesc","getOrientationRotation","w","threed","cosa","sina","ndx","id","pts","color","noise","needvertexgrips","neededgegrips","needfacegrips","boundarygeo","getboundarygeometry","polyn","edges","minx","miny","maxx","maxy","extendedges","f0","f1","f","es","min","max","xoff","yoff","geos","bg","edges2","initv","project2d","connectat","gfi","thisface","caf0","epi","edgename","gf1","gf1i","otherface","mp2","getsolved","colormap","facegeo","hix","hiy","rot","getInitial3DRotation","sc2","mappt2d","fn","xoff2","xmul","facenum","svg","cubieori","cubieord","graybyori","drawedges","svggrips","onface","pt2","facecoords","addgrip","ep","mpc","vp","html","bc","coords","triarea","colorfrac","stickers","foundations","avgstickerarea","polyarea","stickerColors","orbit","ord","fcoords","grips","bind","axis","divid","cache","orbitNames","moveToKeyString","pgmv","mult","schreierSims","identity","sgs","sgsi","sgslen","Tk","Tklen","knuthb","resolve","knutha","none","sz","tks","sollen","avgs","mults","lensum","multiply","avg","getsgs"],"mappings":"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","file":"static/js/3.8490f362.chunk.js","sourcesContent":["const zeroCache: number[][] = [];\nconst iotaCache: number[][] = [];\n\nexport function zeros(n: number): number[] {\n  if (!zeroCache[n]) {\n    const c = Array(n);\n    for (let i = 0; i < n; i++) {\n      c[i] = 0;\n    }\n    zeroCache[n] = c;\n  }\n  return zeroCache[n];\n}\n\nexport function iota(n: number): number[] {\n  if (!iotaCache[n]) {\n    const c = Array(n);\n    for (let i = 0; i < n; i++) {\n      c[i] = i;\n    }\n    iotaCache[n] = c;\n  }\n  return iotaCache[n];\n}\n\nexport function identity(n: number): Perm {\n  return new Perm(iota(n));\n}\n\nexport function random(n: number): Perm {\n  // random\n  const c = Array(n);\n  for (let i = 0; i < n; i++) {\n    c[i] = i;\n  }\n  for (let i = 0; i < n; i++) {\n    const j = i + Math.floor((n - i) * Math.random());\n    const t = c[i];\n    c[i] = c[j];\n    c[j] = t;\n  }\n  return new Perm(c);\n}\n\nexport function factorial(a: number): number {\n  let r = 1;\n  while (a > 1) {\n    r *= a;\n    a--;\n  }\n  return r;\n}\n\nfunction gcd(a: number, b: number): number {\n  if (a > b) {\n    const t = a;\n    a = b;\n    b = t;\n  }\n  while (a > 0) {\n    const m = b % a;\n    b = a;\n    a = m;\n  }\n  return b;\n}\n\nexport function lcm(a: number, b: number): number {\n  return (a / gcd(a, b)) * b;\n}\n\nexport class Perm {\n  public n: number; // length\n  public p: number[]; // The permutation itself\n  constructor(a: number[]) {\n    this.n = a.length;\n    this.p = a;\n  }\n\n  public toString(): string {\n    // stringify\n    return \"Perm[\" + this.p.join(\" \") + \"]\";\n  }\n\n  public mul(p2: Perm): Perm {\n    // multiply\n    const c: number[] = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[i] = p2.p[this.p[i]];\n    }\n    return new Perm(c);\n  }\n\n  public rmul(p2: Perm): Perm {\n    // multiply the other way\n    const c = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[i] = this.p[p2.p[i]];\n    }\n    return new Perm(c);\n  }\n\n  public inv(): Perm {\n    const c = Array(this.n);\n    for (let i = 0; i < this.n; i++) {\n      c[this.p[i]] = i;\n    }\n    return new Perm(c);\n  }\n\n  public compareTo(p2: Perm): number {\n    // comparison\n    for (let i = 0; i < this.n; i++) {\n      if (this.p[i] !== p2.p[i]) {\n        return this.p[i] - p2.p[i];\n      }\n    }\n    return 0;\n  }\n\n  public toGap(): string {\n    const cyc = new Array<string>();\n    const seen = new Array<boolean>(this.n);\n    for (let i = 0; i < this.p.length; i++) {\n      if (seen[i] || this.p[i] === i) {\n        continue;\n      }\n      const incyc = new Array<number>();\n      for (let j = i; !seen[j]; j = this.p[j]) {\n        incyc.push(1 + j);\n        seen[j] = true;\n      }\n      cyc.push(\"(\" + incyc.join(\",\") + \")\");\n    }\n    return cyc.join(\"\");\n  }\n\n  public order(): number {\n    let r = 1;\n    const seen = new Array<boolean>(this.n);\n    for (let i = 0; i < this.p.length; i++) {\n      if (seen[i] || this.p[i] === i) {\n        continue;\n      }\n      let cs = 0;\n      for (let j = i; !seen[j]; j = this.p[j]) {\n        cs++;\n        seen[j] = true;\n      }\n      r = lcm(r, cs);\n    }\n    return r;\n  }\n}\n","import { PGVendoredKPuzzleDefinition } from \"./interfaces\"; // TODO\n/* tslint:disable no-bitwise */\n/* tslint:disable prefer-for-of */ import {\n  factorial,\n  iota,\n  lcm,\n  Perm,\n  zeros,\n} from \"./Perm\";\nexport class OrbitDef {\n  constructor(public size: number, public mod: number) {}\n  public reassemblySize(): number {\n    return factorial(this.size) * Math.pow(this.mod, this.size);\n  }\n}\n\nexport class OrbitsDef {\n  constructor(\n    public orbitnames: string[],\n    public orbitdefs: OrbitDef[],\n    public solved: VisibleState,\n    public movenames: string[],\n    public moveops: Transformation[],\n  ) {}\n\n  public transformToKPuzzle(t: Transformation): any {\n    const mp: { [orbitName: string]: any } = {};\n    for (let j = 0; j < this.orbitnames.length; j++) {\n      mp[this.orbitnames[j]] = t.orbits[j].toKpuzzle();\n    }\n    return mp;\n  }\n\n  public static transformToKPuzzle(\n    orbitnames: string[],\n    t: Transformation,\n  ): any {\n    const mp: { [orbitName: string]: any } = {};\n    for (let j = 0; j < orbitnames.length; j++) {\n      mp[orbitnames[j]] = t.orbits[j].toKpuzzle();\n    }\n    return mp;\n  }\n\n  public toKsolve(name: string, forTwisty: boolean): string[] {\n    const result = [];\n    result.push(\"Name \" + name);\n    result.push(\"\");\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      result.push(\n        \"Set \" +\n          this.orbitnames[i] +\n          \" \" +\n          this.orbitdefs[i].size +\n          \" \" +\n          this.orbitdefs[i].mod,\n      );\n    }\n    result.push(\"\");\n    result.push(\"Solved\");\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      result.push(this.orbitnames[i]);\n      const o = this.solved.orbits[i].toKsolveVS();\n      result.push(o[0]);\n      result.push(o[1]);\n    }\n    result.push(\"End\");\n    result.push(\"\");\n    for (let i = 0; i < this.movenames.length; i++) {\n      result.push(\"Move \" + this.movenames[i]);\n      for (let j = 0; j < this.orbitnames.length; j++) {\n        if (!forTwisty && this.moveops[i].orbits[j].isIdentity()) {\n          continue;\n        }\n        result.push(this.orbitnames[j]);\n        const o = this.moveops[i].orbits[j].toKsolve();\n        result.push(o[0]);\n        result.push(o[1]);\n      }\n      result.push(\"End\");\n      result.push(\"\");\n    }\n    // extra blank line on end lets us use join(\"\\n\") to terminate all\n    return result;\n  }\n\n  // TODO: return type.\n  public toKpuzzle(): PGVendoredKPuzzleDefinition {\n    const orbits: { [orbitName: string]: any } = {};\n    const start: { [orbitName: string]: any } = {};\n    for (let i = 0; i < this.orbitnames.length; i++) {\n      orbits[this.orbitnames[i]] = {\n        numPieces: this.orbitdefs[i].size,\n        orientations: this.orbitdefs[i].mod,\n      };\n      start[this.orbitnames[i]] = this.solved.orbits[i].toKpuzzle();\n    }\n    const moves: { [moveName: string]: any } = {};\n    for (let i = 0; i < this.movenames.length; i++) {\n      moves[this.movenames[i]] = this.transformToKPuzzle(this.moveops[i]);\n    }\n    return { name: \"PG3D\", orbits, startPieces: start, moves };\n  }\n\n  public optimize(): OrbitsDef {\n    const neworbitnames: string[] = [];\n    const neworbitdefs: OrbitDef[] = [];\n    const newsolved: Orbit[] = [];\n    const newmoveops: Orbit[][] = [];\n    for (let j = 0; j < this.moveops.length; j++) {\n      newmoveops.push([]);\n    }\n    for (let i = 0; i < this.orbitdefs.length; i++) {\n      const om = this.orbitdefs[i].mod;\n      const n = this.orbitdefs[i].size;\n      const du = new DisjointUnion(n);\n      const changed = new Array<boolean>(this.orbitdefs[i].size);\n      for (let k = 0; k < n; k++) {\n        changed[k] = false;\n      }\n      for (let j = 0; j < this.moveops.length; j++) {\n        for (let k = 0; k < n; k++) {\n          if (\n            this.moveops[j].orbits[i].perm[k] !== k ||\n            this.moveops[j].orbits[i].ori[k] !== 0\n          ) {\n            changed[k] = true;\n            du.union(k, this.moveops[j].orbits[i].perm[k]);\n          }\n        }\n      }\n      let keepori = true;\n      // right now we kill ori only if solved is unique and\n      // if we can kill it completely.  This is not all the optimization\n      // we can perform.\n      if (om > 1) {\n        keepori = false;\n        const duo = new DisjointUnion(this.orbitdefs[i].size * om);\n        for (let j = 0; j < this.moveops.length; j++) {\n          for (let k = 0; k < n; k++) {\n            if (\n              this.moveops[j].orbits[i].perm[k] !== k ||\n              this.moveops[j].orbits[i].ori[k] !== 0\n            ) {\n              for (let o = 0; o < om; o++) {\n                duo.union(\n                  k * om + o,\n                  this.moveops[j].orbits[i].perm[k] * om +\n                    ((o + this.moveops[j].orbits[i].ori[k]) % om),\n                );\n              }\n            }\n          }\n        }\n        for (let j = 0; !keepori && j < n; j++) {\n          for (let o = 1; o < om; o++) {\n            if (duo.find(j * om) === duo.find(j * om + o)) {\n              keepori = true;\n            }\n          }\n        }\n        for (let j = 0; !keepori && j < n; j++) {\n          for (let k = 0; k < j; k++) {\n            if (\n              this.solved.orbits[i].perm[j] === this.solved.orbits[i].perm[k]\n            ) {\n              keepori = true;\n            }\n          }\n        }\n      }\n      // is there just one result set, or more than one?\n      let nontriv = -1;\n      let multiple = false;\n      for (let j = 0; j < this.orbitdefs[i].size; j++) {\n        if (changed[j]) {\n          const h = du.find(j);\n          if (nontriv < 0) {\n            nontriv = h;\n          } else if (nontriv !== h) {\n            multiple = true;\n          }\n        }\n      }\n      for (let j = 0; j < this.orbitdefs[i].size; j++) {\n        if (!changed[j]) {\n          continue;\n        }\n        const h = du.find(j);\n        if (h !== j) {\n          continue;\n        }\n        const no: number[] = [];\n        const on: number[] = [];\n        let nv = 0;\n        for (let k = 0; k < this.orbitdefs[i].size; k++) {\n          if (du.find(k) === j) {\n            no[nv] = k;\n            on[k] = nv;\n            nv++;\n          }\n        }\n        if (multiple) {\n          neworbitnames.push(this.orbitnames[i] + \"_p\" + j);\n        } else {\n          neworbitnames.push(this.orbitnames[i]);\n        }\n        if (keepori) {\n          neworbitdefs.push(new OrbitDef(nv, this.orbitdefs[i].mod));\n          newsolved.push(this.solved.orbits[i].remapVS(no, nv));\n          for (let k = 0; k < this.moveops.length; k++) {\n            newmoveops[k].push(this.moveops[k].orbits[i].remap(no, on, nv));\n          }\n        } else {\n          neworbitdefs.push(new OrbitDef(nv, 1));\n          newsolved.push(this.solved.orbits[i].remapVS(no, nv).killOri());\n          for (let k = 0; k < this.moveops.length; k++) {\n            newmoveops[k].push(\n              this.moveops[k].orbits[i].remap(no, on, nv).killOri(),\n            );\n          }\n        }\n      }\n    }\n    return new OrbitsDef(\n      neworbitnames,\n      neworbitdefs,\n      new VisibleState(newsolved),\n      this.movenames,\n      newmoveops.map((_) => new Transformation(_)),\n    );\n  }\n\n  // generate a new \"solved\" position based on scrambling\n  // we use an algorithm that should be faster for large puzzles than\n  // just picking random moves.\n  public scramble(n: number): void {\n    const pool: Transformation[] = [];\n    for (let i = 0; i < this.moveops.length; i++) {\n      pool[i] = this.moveops[i];\n    }\n    for (let i = 0; i < pool.length; i++) {\n      const j = Math.floor(Math.random() * pool.length);\n      const t = pool[i];\n      pool[i] = pool[j];\n      pool[j] = t;\n    }\n    if (n < pool.length) {\n      n = pool.length;\n    }\n    for (let i = 0; i < n; i++) {\n      const ri = Math.floor(Math.random() * pool.length);\n      const rj = Math.floor(Math.random() * pool.length);\n      const rm = Math.floor(Math.random() * this.moveops.length);\n      pool[ri] = pool[ri].mul(pool[rj]).mul(this.moveops[rm]);\n      if (Math.random() < 0.1) {\n        // break up parity\n        pool[ri] = pool[ri].mul(this.moveops[rm]);\n      }\n    }\n    let s = pool[0];\n    for (let i = 1; i < pool.length; i++) {\n      s = s.mul(pool[i]);\n    }\n    this.solved = this.solved.mul(s);\n  }\n\n  public reassemblySize(): number {\n    let n = 1;\n    for (let i = 0; i < this.orbitdefs.length; i++) {\n      n *= this.orbitdefs[i].reassemblySize();\n    }\n    return n;\n  }\n}\n\nexport class Orbit {\n  static kcache: Record<string, unknown>[] = [];\n\n  public static e(n: number, mod: number): Orbit {\n    return new Orbit(iota(n), zeros(n), mod);\n  }\n\n  constructor(\n    public perm: number[],\n    public ori: number[],\n    public orimod: number,\n  ) {}\n\n  public mul(b: Orbit): Orbit {\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n);\n    if (this.orimod === 1) {\n      for (let i = 0; i < n; i++) {\n        newPerm[i] = this.perm[b.perm[i]];\n      }\n      return new Orbit(newPerm, this.ori, this.orimod);\n    } else {\n      const newOri = new Array<number>(n);\n      for (let i = 0; i < n; i++) {\n        newPerm[i] = this.perm[b.perm[i]];\n        newOri[i] = (this.ori[b.perm[i]] + b.ori[i]) % this.orimod;\n      }\n      return new Orbit(newPerm, newOri, this.orimod);\n    }\n  }\n\n  public inv(): Orbit {\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n);\n    const newOri = new Array<number>(n);\n    for (let i = 0; i < n; i++) {\n      newPerm[this.perm[i]] = i;\n      newOri[this.perm[i]] = (this.orimod - this.ori[i]) % this.orimod;\n    }\n    return new Orbit(newPerm, newOri, this.orimod);\n  }\n\n  public equal(b: Orbit): boolean {\n    const n = this.perm.length;\n    for (let i = 0; i < n; i++) {\n      if (this.perm[i] !== b.perm[i] || this.ori[i] !== b.ori[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // in-place mutator\n  public killOri(): this {\n    const n = this.perm.length;\n    for (let i = 0; i < n; i++) {\n      this.ori[i] = 0;\n    }\n    this.orimod = 1;\n    return this;\n  }\n\n  public toPerm(): Perm {\n    const o = this.orimod;\n    if (o === 1) {\n      return new Perm(this.perm);\n    }\n    const n = this.perm.length;\n    const newPerm = new Array<number>(n * o);\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < o; j++) {\n        newPerm[i * o + j] = o * this.perm[i] + ((this.ori[i] + j) % o);\n      }\n    }\n    return new Perm(newPerm);\n  }\n\n  // returns tuple of sets of identical pieces in this orbit\n  public identicalPieces(): number[][] {\n    const done: boolean[] = [];\n    const n = this.perm.length;\n    const r: number[][] = [];\n    for (let i = 0; i < n; i++) {\n      const v = this.perm[i];\n      if (done[v] === undefined) {\n        const s: number[] = [i];\n        done[v] = true;\n        for (let j = i + 1; j < n; j++) {\n          if (this.perm[j] === v) {\n            s.push(j);\n          }\n        }\n        r.push(s);\n      }\n    }\n    return r;\n  }\n\n  public order(): number {\n    // can be made more efficient\n    return this.toPerm().order();\n  }\n\n  public isIdentity(): boolean {\n    const n = this.perm.length;\n    if (this.perm === iota(n) && this.ori === zeros(n)) {\n      return true;\n    }\n    for (let i = 0; i < n; i++) {\n      if (this.perm[i] !== i || this.ori[i] !== 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  public remap(no: number[], on: number[], nv: number): Orbit {\n    const newPerm = new Array<number>(nv);\n    const newOri = new Array<number>(nv);\n    for (let i = 0; i < nv; i++) {\n      newPerm[i] = on[this.perm[no[i]]];\n      newOri[i] = this.ori[no[i]];\n    }\n    return new Orbit(newPerm, newOri, this.orimod);\n  }\n\n  public remapVS(no: number[], nv: number): Orbit {\n    const newPerm = new Array<number>(nv);\n    const newOri = new Array<number>(nv);\n    let nextNew = 0;\n    const reassign = [];\n    for (let i = 0; i < nv; i++) {\n      const ov = this.perm[no[i]];\n      if (reassign[ov] === undefined) {\n        reassign[ov] = nextNew++;\n      }\n      newPerm[i] = reassign[ov];\n      newOri[i] = this.ori[no[i]];\n    }\n    return new Orbit(newPerm, newOri, this.orimod);\n  }\n\n  public toKsolveVS(): string[] {\n    return [this.perm.map((_: number) => _ + 1).join(\" \"), this.ori.join(\" \")];\n  }\n\n  public toKsolve(): string[] {\n    const newori = new Array<number>(this.ori.length);\n    for (let i = 0; i < newori.length; i++) {\n      newori[this.perm[i]] = this.ori[i];\n    }\n    return [this.perm.map((_: number) => _ + 1).join(\" \"), newori.join(\" \")];\n  }\n\n  // TODO: return type\n  public toKpuzzle(): Record<string, unknown> {\n    const n = this.perm.length;\n    if (this.isIdentity()) {\n      if (!Orbit.kcache[n]) {\n        Orbit.kcache[n] = { permutation: iota(n), orientation: zeros(n) };\n      }\n      return Orbit.kcache[n];\n    } else {\n      return { permutation: this.perm, orientation: this.ori };\n    }\n  }\n}\nexport class TransformationBase {\n  constructor(public orbits: Orbit[]) {}\n  public internalMul(b: TransformationBase): Orbit[] {\n    const newOrbits: Orbit[] = [];\n    for (let i = 0; i < this.orbits.length; i++) {\n      newOrbits.push(this.orbits[i].mul(b.orbits[i]));\n    }\n    return newOrbits;\n  }\n\n  public internalInv(): Orbit[] {\n    const newOrbits: Orbit[] = [];\n    for (let i = 0; i < this.orbits.length; i++) {\n      newOrbits.push(this.orbits[i].inv());\n    }\n    return newOrbits;\n  }\n\n  public equal(b: TransformationBase): boolean {\n    for (let i = 0; i < this.orbits.length; i++) {\n      if (!this.orbits[i].equal(b.orbits[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  public killOri(): this {\n    for (let i = 0; i < this.orbits.length; i++) {\n      this.orbits[i].killOri();\n    }\n    return this;\n  }\n\n  public toPerm(): Perm {\n    const perms = new Array<Perm>();\n    let n = 0;\n    for (let i = 0; i < this.orbits.length; i++) {\n      const p = this.orbits[i].toPerm();\n      perms.push(p);\n      n += p.n;\n    }\n    const newPerm = new Array<number>(n);\n    n = 0;\n    for (let i = 0; i < this.orbits.length; i++) {\n      const p = perms[i];\n      for (let j = 0; j < p.n; j++) {\n        newPerm[n + j] = n + p.p[j];\n      }\n      n += p.n;\n    }\n    return new Perm(newPerm);\n  }\n\n  public identicalPieces(): number[][] {\n    const r: number[][] = [];\n    let n = 0;\n    for (let i = 0; i < this.orbits.length; i++) {\n      const o = this.orbits[i].orimod;\n      const s = this.orbits[i].identicalPieces();\n      for (let j = 0; j < s.length; j++) {\n        r.push(s[j].map((_) => _ * o + n));\n      }\n      n += o * this.orbits[i].perm.length;\n    }\n    return r;\n  }\n\n  public order(): number {\n    let r = 1;\n    for (let i = 0; i < this.orbits.length; i++) {\n      r = lcm(r, this.orbits[i].order());\n    }\n    return r;\n  }\n}\nexport class Transformation extends TransformationBase {\n  constructor(orbits: Orbit[]) {\n    super(orbits);\n  }\n\n  public mul(b: Transformation): Transformation {\n    return new Transformation(this.internalMul(b));\n  }\n\n  public mulScalar(n: number): Transformation {\n    if (n === 0) {\n      return this.e();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let t: Transformation = this;\n    if (n < 0) {\n      t = t.inv();\n      n = -n;\n    }\n    while ((n & 1) === 0) {\n      t = t.mul(t);\n      n >>= 1;\n    }\n    if (n === 1) {\n      return t;\n    }\n    let s = t;\n    let r = this.e();\n    while (n > 0) {\n      if (n & 1) {\n        r = r.mul(s);\n      }\n      if (n > 1) {\n        s = s.mul(s);\n      }\n      n >>= 1;\n    }\n    return r;\n  }\n\n  public inv(): Transformation {\n    return new Transformation(this.internalInv());\n  }\n\n  public e(): Transformation {\n    return new Transformation(\n      this.orbits.map((_: Orbit) => Orbit.e(_.perm.length, _.orimod)),\n    );\n  }\n}\nexport class VisibleState extends TransformationBase {\n  constructor(orbits: Orbit[]) {\n    super(orbits);\n  }\n\n  public mul(b: Transformation): VisibleState {\n    return new VisibleState(this.internalMul(b));\n  }\n}\n//  Disjoint set union implementation.\nclass DisjointUnion {\n  public heads: number[];\n  constructor(public n: number) {\n    this.heads = new Array<number>(n);\n    for (let i = 0; i < n; i++) {\n      this.heads[i] = i;\n    }\n  }\n\n  public find(v: number): number {\n    let h = this.heads[v];\n    if (this.heads[h] === h) {\n      return h;\n    }\n    h = this.find(this.heads[h]);\n    this.heads[v] = h;\n    return h;\n  }\n\n  public union(a: number, b: number): void {\n    const ah = this.find(a);\n    const bh = this.find(b);\n    if (ah < bh) {\n      this.heads[bh] = ah;\n    } else if (ah > bh) {\n      this.heads[ah] = bh;\n    }\n  }\n}\nexport function showcanon(g: OrbitsDef, disp: (s: string) => void): void {\n  // show information for canonical move derivation\n  const n = g.moveops.length;\n  if (n > 30) {\n    throw new Error(\"Canon info too big for bitmask\");\n  }\n  const orders = [];\n  const commutes = [];\n  for (let i = 0; i < n; i++) {\n    const permA = g.moveops[i];\n    orders.push(permA.order());\n    let bits = 0;\n    for (let j = 0; j < n; j++) {\n      if (j === i) {\n        continue;\n      }\n      const permB = g.moveops[j];\n      if (permA.mul(permB).equal(permB.mul(permA))) {\n        bits |= 1 << j;\n      }\n    }\n    commutes.push(bits);\n  }\n  let curlev: any = {};\n  curlev[0] = 1;\n  for (let d = 0; d < 100; d++) {\n    let sum = 0;\n    const nextlev: any = {};\n    let uniq = 0;\n    for (const sti in curlev) {\n      const st = +sti; // string to number\n      const cnt = curlev[st];\n      sum += cnt;\n      uniq++;\n      for (let mv = 0; mv < orders.length; mv++) {\n        if (\n          ((st >> mv) & 1) === 0 &&\n          (st & commutes[mv] & ((1 << mv) - 1)) === 0\n        ) {\n          const nst = (st & commutes[mv]) | (1 << mv);\n          if (nextlev[nst] === undefined) {\n            nextlev[nst] = 0;\n          }\n          nextlev[nst] += (orders[mv] - 1) * cnt;\n        }\n      }\n    }\n    disp(\"\" + d + \": canonseq \" + sum + \" states \" + uniq);\n    curlev = nextlev;\n  }\n}\n// This is a less effective canonicalization (that happens to work fine\n// for the 3x3x3).  We include this only for comparison.\nexport function showcanon0(g: OrbitsDef, disp: (s: string) => void): void {\n  // show information for canonical move derivation\n  const n = g.moveops.length;\n  if (n > 30) {\n    throw new Error(\"Canon info too big for bitmask\");\n  }\n  const orders = [];\n  const commutes = [];\n  for (let i = 0; i < n; i++) {\n    const permA = g.moveops[i];\n    orders.push(permA.order());\n    let bits = 0;\n    for (let j = 0; j < n; j++) {\n      if (j === i) {\n        continue;\n      }\n      const permB = g.moveops[j];\n      if (permA.mul(permB).equal(permB.mul(permA))) {\n        bits |= 1 << j;\n      }\n    }\n    commutes.push(bits);\n  }\n  let curlev: any = {};\n  disp(\"\" + 0 + \": canonseq \" + 1);\n  for (let x = 0; x < orders.length; x++) {\n    curlev[x] = orders[x] - 1;\n  }\n  for (let d = 1; d < 100; d++) {\n    let sum = 0;\n    const nextlev: any = {};\n    let uniq = 0;\n    for (const sti in curlev) {\n      const st = +sti; // string to number\n      const cnt = curlev[st];\n      sum += cnt;\n      uniq++;\n      for (let mv = 0; mv < orders.length; mv++) {\n        if (mv === st || (commutes[mv] & (1 << st) && mv < st)) {\n          continue;\n        }\n        if (nextlev[mv] === undefined) {\n          nextlev[mv] = 0;\n        }\n        nextlev[mv] += (orders[mv] - 1) * cnt;\n      }\n    }\n    disp(\"\" + d + \": canonseq \" + sum + \" states \" + uniq);\n    curlev = nextlev;\n  }\n}\n","// Manages a set of face names.  Detects whether they are prefix-free.\n// Implements greedy splitting into face names and comparisons between\n// concatenated face names and grip names.\n\nexport class FaceNameSwizzler {\n  public prefixFree: boolean = true;\n  public gripnames: string[] = [];\n  constructor(public facenames: string[], gripnames_arg?: string[]) {\n    if (gripnames_arg) {\n      this.gripnames = gripnames_arg;\n    }\n    for (let i = 0; this.prefixFree && i < facenames.length; i++) {\n      for (let j = 0; this.prefixFree && j < facenames.length; j++) {\n        if (i !== j && facenames[i].startsWith(facenames[j])) {\n          this.prefixFree = false;\n        }\n      }\n    }\n  }\n\n  public setGripNames(names: string[]): void {\n    this.gripnames = names;\n  }\n\n  // split a string into face names and return a list of\n  // indices.\n  public splitByFaceNames(s: string): number[] {\n    const r = [];\n    let at = 0;\n    while (at < s.length) {\n      if (at > 0 && at < s.length && s[at] === \"_\") {\n        at++;\n      }\n      let currentMatch = -1;\n      for (let i = 0; i < this.facenames.length; i++) {\n        if (\n          s.substr(at).startsWith(this.facenames[i]) &&\n          (currentMatch < 0 ||\n            this.facenames[i].length > this.facenames[currentMatch].length)\n        ) {\n          currentMatch = i;\n        }\n      }\n      if (currentMatch >= 0) {\n        r.push(currentMatch);\n        at += this.facenames[currentMatch].length;\n      } else {\n        throw new Error(\"Could not split \" + s + \" into face names.\");\n      }\n    }\n    return r;\n  }\n\n  // cons a grip from an array of numbers.\n  public joinByFaceIndices(list: number[]): string {\n    let sep = \"\";\n    const r = [];\n    for (let i = 0; i < list.length; i++) {\n      r.push(sep);\n      r.push(this.facenames[list[i]]);\n      if (!this.prefixFree) {\n        sep = \"_\";\n      }\n    }\n    return r.join(\"\");\n  }\n\n  /*\n   *   Try to match something the user gave us with some geometric\n   *   feature.  We used to have strict requirements:\n   *\n   *      a)  The set of face names are prefix free\n   *      b)  When specifying a corner, all coincident planes were\n   *          specified\n   *\n   *   But, to allow megaminx to have more reasonable and\n   *   conventional names, and to permit shorter canonical\n   *   names, we are relaxing these requirements and adding\n   *   new syntax.  Now:\n   *\n   *      a)  Face names need not be syntax free.\n   *      b)  When parsing a geometric name, we use greedy\n   *          matching, so the longest name that matches the\n   *          user string at the current position is the one\n   *          assumed to match.\n   *      c)  Underscores are permitted to separate face names\n   *          (both in user input and in geometric\n   *          descriptions).\n   *      d)  Default names of corner moves where corners have\n   *          more than three corners, need only include three\n   *          of the corners.\n   *\n   *   This code is not performance-sensitive so we can do it a\n   *   slow and simple way.\n   */\n  public spinmatch(userinput: string, longname: string): boolean {\n    // are these the same rotationally?\n    if (userinput === longname) {\n      return true;\n    }\n    try {\n      const e1 = this.splitByFaceNames(userinput);\n      const e2 = this.splitByFaceNames(longname);\n      // All elements of userinput need to be in the longname.\n      // There should be no duplicate elements in the userinput.\n      // if both have length 1 or length 2, the sets must be equal.\n      // if both have length 3 or more, then the first set must be\n      // a subset of the second.  Order doesn't matter.\n      if (e1.length !== e2.length && e1.length < 3) {\n        return false;\n      }\n      for (let i = 0; i < e1.length; i++) {\n        for (let j = 0; j < i; j++) {\n          if (e1[i] === e1[j]) {\n            return false;\n          }\n        }\n        let found = false;\n        for (let j = 0; j < e2.length; j++) {\n          if (e1[i] === e2[j]) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          return false;\n        }\n      }\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  public unswizzle(s: string): string {\n    if ((s.endsWith(\"v\") || s.endsWith(\"w\")) && s[0] <= \"Z\") {\n      s = s.slice(0, s.length - 1);\n    }\n    const upperCaseGrip = s.toUpperCase();\n    for (let i = 0; i < this.gripnames.length; i++) {\n      const g = this.gripnames[i];\n      if (this.spinmatch(upperCaseGrip, g)) {\n        return g;\n      }\n    }\n    return s;\n  }\n}\n","import { FaceNameSwizzler } from \"./FaceNameSwizzler\";\nimport { Move, QuantumMove } from \"../alg\";\n\nexport interface NotationMapper {\n  notationToInternal(move: Move): Move | null;\n  notationToExternal(move: Move): Move | null;\n}\n\nexport class NullMapper implements NotationMapper {\n  public notationToInternal(move: Move): Move {\n    return move;\n  }\n\n  public notationToExternal(move: Move): Move {\n    return move;\n  }\n}\n\nfunction negate(family: string, v: number | undefined): Move {\n  if (v === undefined) {\n    v = -1;\n  } else if (v === -1) {\n    v = undefined;\n  } else {\n    v = -v;\n  }\n  return new Move(family, v);\n}\n\nexport class NxNxNCubeMapper implements NotationMapper {\n  constructor(public slices: number) {}\n\n  public notationToInternal(move: Move): Move {\n    const grip = move.family;\n    if (!move.innerLayer && !move.outerLayer) {\n      if (grip === \"x\") {\n        move = new Move(\"Rv\", move.effectiveAmount);\n      } else if (grip === \"y\") {\n        move = new Move(\"Uv\", move.effectiveAmount);\n      } else if (grip === \"z\") {\n        move = new Move(\"Fv\", move.effectiveAmount);\n      }\n      if ((this.slices & 1) === 1) {\n        if (grip === \"E\") {\n          move = new Move(\n            new QuantumMove(\"D\", (this.slices + 1) / 2),\n            move.effectiveAmount,\n          );\n        } else if (grip === \"M\") {\n          move = new Move(\n            new QuantumMove(\"L\", (this.slices + 1) / 2),\n            move.effectiveAmount,\n          );\n        } else if (grip === \"S\") {\n          move = new Move(\n            new QuantumMove(\"F\", (this.slices + 1) / 2),\n            move.effectiveAmount,\n          );\n        }\n      }\n      if (this.slices > 2) {\n        if (grip === \"e\") {\n          move = new Move(\n            new QuantumMove(\"D\", this.slices - 1, 2),\n            move.effectiveAmount,\n          );\n        } else if (grip === \"m\") {\n          move = new Move(\n            new QuantumMove(\"L\", this.slices - 1, 2),\n            move.effectiveAmount,\n          );\n        } else if (grip === \"s\") {\n          move = new Move(\n            new QuantumMove(\"F\", this.slices - 1, 2),\n            move.effectiveAmount,\n          );\n        }\n      }\n    }\n    return move;\n  }\n\n  // do we want to map slice moves to E/M/S instead of 2U/etc.?\n  public notationToExternal(move: Move): Move {\n    const grip = move.family;\n    if (!move.innerLayer && !move.outerLayer) {\n      if (grip === \"Rv\") {\n        return new Move(\"x\", move.effectiveAmount);\n      } else if (grip === \"Uv\") {\n        return new Move(\"y\", move.effectiveAmount);\n      } else if (grip === \"Fv\") {\n        return new Move(\"z\", move.effectiveAmount);\n      } else if (grip === \"Lv\") {\n        return negate(\"x\", move.effectiveAmount);\n      } else if (grip === \"Dv\") {\n        return negate(\"y\", move.effectiveAmount);\n      } else if (grip === \"Bv\") {\n        return negate(\"z\", move.effectiveAmount);\n      }\n    }\n    return move;\n  }\n}\n\n// face renaming mapper.  Accepts two face name remappers.  We\n// work between the two.\n\nexport class FaceRenamingMapper implements NotationMapper {\n  constructor(\n    public internalNames: FaceNameSwizzler,\n    public externalNames: FaceNameSwizzler,\n  ) {}\n\n  // TODO:  consider putting a cache in front of this\n  public convertString(\n    grip: string,\n    a: FaceNameSwizzler,\n    b: FaceNameSwizzler,\n  ): string {\n    let suffix = \"\";\n    if ((grip.endsWith(\"v\") || grip.endsWith(\"v\")) && grip <= \"_\") {\n      suffix = grip.slice(grip.length - 1);\n      grip = grip.slice(0, grip.length - 1);\n    }\n    const upper = grip.toUpperCase();\n    let isLowerCase = false;\n    if (grip !== upper) {\n      isLowerCase = true;\n      grip = upper;\n    }\n    grip = b.joinByFaceIndices(a.splitByFaceNames(grip));\n    if (isLowerCase) {\n      grip = grip.toLowerCase();\n    }\n    return grip + suffix;\n  }\n\n  public convert(move: Move, a: FaceNameSwizzler, b: FaceNameSwizzler): Move {\n    const grip = move.family;\n    const ngrip = this.convertString(grip, a, b);\n    if (grip === ngrip) {\n      return move;\n    } else {\n      return new Move(\n        new QuantumMove(ngrip, move.innerLayer, move.outerLayer),\n        move.effectiveAmount,\n      );\n    }\n  }\n\n  public notationToInternal(move: Move): Move {\n    const r = this.convert(move, this.externalNames, this.internalNames);\n    return r;\n  }\n\n  public notationToExternal(move: Move): Move {\n    return this.convert(move, this.internalNames, this.externalNames);\n  }\n}\n\n// Sits on top of a (possibly null) notation mapper, and\n// adds R++/R--/D++/D-- notation mapping.\nexport class MegaminxScramblingNotationMapper implements NotationMapper {\n  constructor(private child: NotationMapper) {}\n\n  public notationToInternal(move: Move): Move | null {\n    if (move.innerLayer === undefined && move.outerLayer === undefined) {\n      if (Math.abs(move.effectiveAmount) === 1) {\n        if (move.family === \"R++\") {\n          return new Move(\n            new QuantumMove(\"L\", 3, 2),\n            -2 * move.effectiveAmount,\n          );\n        } else if (move.family === \"R--\") {\n          return new Move(new QuantumMove(\"L\", 3, 2), 2 * move.effectiveAmount);\n        } else if (move.family === \"D++\") {\n          return new Move(\n            new QuantumMove(\"U\", 3, 2),\n            -2 * move.effectiveAmount,\n          );\n        } else if (move.family === \"D--\") {\n          return new Move(new QuantumMove(\"U\", 3, 2), 2 * move.effectiveAmount);\n        }\n      }\n      if (move.family === \"y\") {\n        return new Move(\"Uv\", move.effectiveAmount);\n      }\n    }\n    return this.child.notationToInternal(move);\n  }\n\n  // we never rewrite click moves to these moves.\n  public notationToExternal(move: Move): Move | null {\n    if (move.family === \"Uv\") {\n      return new Move(\n        new QuantumMove(\"y\", move.innerLayer, move.outerLayer),\n        move.effectiveAmount,\n      );\n    }\n    if (move.family === \"Dv\") {\n      return negate(\"y\", move.effectiveAmount);\n    }\n    return this.child.notationToExternal(move);\n  }\n}\n\nexport class SkewbNotationMapper implements NotationMapper {\n  constructor(private child: FaceNameSwizzler) {}\n\n  public notationToInternal(move: Move): Move | null {\n    if (move.innerLayer || move.outerLayer) {\n      return null;\n    }\n    if (move.family === \"F\") {\n      return new Move(\n        new QuantumMove(\"DFR\", move.outerLayer, move.innerLayer),\n        move.effectiveAmount,\n      );\n    } else if (move.family === \"R\") {\n      return new Move(\n        new QuantumMove(\"DBR\", move.outerLayer, move.innerLayer),\n        move.effectiveAmount,\n      );\n    } else if (move.family === \"L\") {\n      return new Move(\n        new QuantumMove(\"DFL\", move.outerLayer, move.innerLayer),\n        move.effectiveAmount,\n      );\n    } else if (move.family === \"B\") {\n      return new Move(\n        new QuantumMove(\"DBL\", move.outerLayer, move.innerLayer),\n        move.effectiveAmount,\n      );\n      /*\n       *   (1) We are not including x/y/z in Skewb; they aren't WCA notation and\n       *   it's unclear anyone needs them for reconstructions.\n       *\n    } else if (move.family === \"x\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"Rv\", move.amount);\n    } else if (move.family === \"y\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"Uv\", move.amount);\n    } else if (move.family === \"z\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"Fv\", move.amount);\n       */\n    } else {\n      return null;\n    }\n  }\n\n  // we never rewrite click moves to these moves.\n  public notationToExternal(move: Move): Move | null {\n    if (this.child.spinmatch(move.family, \"DFR\")) {\n      return new Move(\n        new QuantumMove(\"F\", move.innerLayer, move.outerLayer),\n        move.effectiveAmount,\n      );\n    } else if (this.child.spinmatch(move.family, \"DRB\")) {\n      return new Move(\n        new QuantumMove(\"R\", move.innerLayer, move.outerLayer),\n        move.effectiveAmount,\n      );\n    } else if (this.child.spinmatch(move.family, \"DFL\")) {\n      return new Move(\n        new QuantumMove(\"L\", move.innerLayer, move.outerLayer),\n        move.effectiveAmount,\n      );\n    } else if (this.child.spinmatch(move.family, \"DBL\")) {\n      return new Move(\n        new QuantumMove(\"B\", move.innerLayer, move.outerLayer),\n        move.effectiveAmount,\n      );\n      /*\n       *   See (1) above.\n       *\n    } else if (move.family === \"Rv\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"x\", move.amount);\n    } else if (move.family === \"Uv\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"y\", move.amount);\n    } else if (move.family === \"Fv\") {\n      return new BlockMove(move.outerLayer, move.innerLayer, \"z\", move.amount);\n       */\n    } else {\n      return null;\n    }\n  }\n}\n\nexport class PyraminxNotationMapper implements NotationMapper {\n  constructor(private child: FaceNameSwizzler) {}\n\n  public notationToInternal(move: Move): Move | null {\n    if (move.innerLayer || move.outerLayer) {\n      return null;\n    }\n    if (move.family === \"U\") {\n      return new Move(\n        new QuantumMove(\"flr\", move.innerLayer, move.outerLayer),\n        move.effectiveAmount,\n      );\n    } else if (move.family === \"R\") {\n      return new Move(\n        new QuantumMove(\"fld\", move.innerLayer, move.outerLayer),\n        move.effectiveAmount,\n      );\n    } else if (move.family === \"L\") {\n      return new Move(\n        new QuantumMove(\"frd\", move.innerLayer, move.outerLayer),\n        move.effectiveAmount,\n      );\n    } else if (move.family === \"B\") {\n      return new Move(\n        new QuantumMove(\"dlr\", move.innerLayer, move.outerLayer),\n        move.effectiveAmount,\n      );\n    } else if (move.family === \"u\") {\n      return new Move(\n        new QuantumMove(\"FLR\", move.innerLayer, move.outerLayer),\n        move.effectiveAmount,\n      );\n    } else if (move.family === \"r\") {\n      return new Move(\n        new QuantumMove(\"FLD\", move.innerLayer, move.outerLayer),\n        move.effectiveAmount,\n      );\n    } else if (move.family === \"l\") {\n      return new Move(\n        new QuantumMove(\"FRD\", move.innerLayer, move.outerLayer),\n        move.effectiveAmount,\n      );\n    } else if (move.family === \"b\") {\n      return new Move(\n        new QuantumMove(\"DLR\", move.innerLayer, move.outerLayer),\n        move.effectiveAmount,\n      );\n    } else if (move.family === \"y\") {\n      return negate(\"Dv\", move.effectiveAmount);\n    } else {\n      return null;\n    }\n  }\n\n  // we never rewrite click moves to these moves.\n  public notationToExternal(move: Move): Move | null {\n    if (move.family === move.family.toLowerCase()) {\n      const fam = move.family.toUpperCase();\n      if (this.child.spinmatch(fam, \"FLR\")) {\n        return new Move(\n          new QuantumMove(\"U\", move.innerLayer, move.outerLayer),\n          move.effectiveAmount,\n        );\n      } else if (this.child.spinmatch(fam, \"FLD\")) {\n        return new Move(\n          new QuantumMove(\"R\", move.innerLayer, move.outerLayer),\n          move.effectiveAmount,\n        );\n      } else if (this.child.spinmatch(fam, \"FRD\")) {\n        return new Move(\n          new QuantumMove(\"L\", move.innerLayer, move.outerLayer),\n          move.effectiveAmount,\n        );\n      } else if (this.child.spinmatch(fam, \"DLR\")) {\n        return new Move(\n          new QuantumMove(\"B\", move.innerLayer, move.outerLayer),\n          move.effectiveAmount,\n        );\n      }\n    }\n    if (move.family === move.family.toUpperCase()) {\n      if (this.child.spinmatch(move.family, \"FLR\")) {\n        return new Move(\n          new QuantumMove(\"u\", move.innerLayer, move.outerLayer),\n          move.effectiveAmount,\n        );\n      } else if (this.child.spinmatch(move.family, \"FLD\")) {\n        return new Move(\n          new QuantumMove(\"r\", move.innerLayer, move.outerLayer),\n          move.effectiveAmount,\n        );\n      } else if (this.child.spinmatch(move.family, \"FRD\")) {\n        return new Move(\n          new QuantumMove(\"l\", move.innerLayer, move.outerLayer),\n          move.effectiveAmount,\n        );\n      } else if (this.child.spinmatch(move.family, \"DLR\")) {\n        return new Move(\n          new QuantumMove(\"b\", move.innerLayer, move.outerLayer),\n          move.effectiveAmount,\n        );\n      }\n    }\n    if (move.family === \"Dv\") {\n      return negate(\"y\", move.effectiveAmount);\n    } else {\n      return null;\n    }\n  }\n}\n\nexport class FTONotationMapper implements NotationMapper {\n  constructor(private child: NotationMapper, private sw: FaceNameSwizzler) {}\n\n  public notationToInternal(move: Move): Move | null {\n    if (\n      move.family === \"T\" &&\n      move.innerLayer === undefined &&\n      move.outerLayer === undefined\n    ) {\n      return new Move(\n        new QuantumMove(\"FLRv\", move.innerLayer, move.outerLayer),\n        move.effectiveAmount,\n      );\n    } else {\n      const r = this.child.notationToInternal(move);\n      return r;\n    }\n  }\n\n  // we never rewrite click moves to these moves.\n  public notationToExternal(move: Move): Move | null {\n    let fam = move.family;\n    if (fam.length > 0 && fam[fam.length - 1] === \"v\") {\n      fam = fam.substring(0, fam.length - 1);\n    }\n    if (this.sw.spinmatch(fam, \"FLUR\")) {\n      return new Move(\n        new QuantumMove(\"T\", move.innerLayer, move.outerLayer),\n        move.effectiveAmount,\n      );\n    }\n    return this.child.notationToExternal(move);\n  }\n}\n","export type PuzzleDescriptionString = string;\n\nexport const PGPuzzles: { [name: string]: PuzzleDescriptionString } = {\n  \"2x2x2\": \"c f 0\",\n  \"3x3x3\": \"c f 0.333333333333333\",\n  \"4x4x4\": \"c f 0.5 f 0\",\n  \"5x5x5\": \"c f 0.6 f 0.2\",\n  \"6x6x6\": \"c f 0.666666666666667 f 0.333333333333333 f 0\",\n  \"7x7x7\": \"c f 0.714285714285714 f 0.428571428571429 f 0.142857142857143\",\n  \"8x8x8\": \"c f 0.75 f 0.5 f 0.25 f 0\",\n  \"9x9x9\":\n    \"c f 0.777777777777778 f 0.555555555555556 f 0.333333333333333 f 0.111111111111111\",\n  \"10x10x10\": \"c f 0.8 f 0.6 f 0.4 f 0.2 f 0\",\n  \"11x11x11\":\n    \"c f 0.818181818181818 f 0.636363636363636 f 0.454545454545455 f 0.272727272727273 f 0.0909090909090909\",\n  \"12x12x12\":\n    \"c f 0.833333333333333 f 0.666666666666667 f 0.5 f 0.333333333333333 f 0.166666666666667 f 0\",\n  \"13x13x13\":\n    \"c f 0.846153846153846 f 0.692307692307692 f 0.538461538461538 f 0.384615384615385 f 0.230769230769231 f 0.0769230769230769\",\n  \"20x20x20\": \"c f 0 f .1 f .2 f .3 f .4 f .5 f .6 f .7 f .8 f .9\",\n  \"30x30x30\":\n    \"c f 0 f .066667 f .133333 f .2 f .266667 f .333333 f .4 f .466667 f .533333 f .6 f .666667 f .733333 f .8 f .866667 f .933333\",\n  \"40x40x40\":\n    \"c f 0 f .05 f .1 f .15 f .2 f .25 f .3 f .35 f .4 f .45 f .5 f .55 f .6 f .65 f .7 f .75 f .8 f .85 f .9 f .95\",\n  \"skewb\": \"c v 0\",\n  \"master skewb\": \"c v 0.275\",\n  \"professor skewb\": \"c v 0 v 0.38\",\n  \"compy cube\": \"c v 0.915641442663986\",\n  \"helicopter\": \"c e 0.707106781186547\",\n  \"curvy copter\": \"c e 0.83\",\n  \"dino\": \"c v 0.577350269189626\",\n  \"little chop\": \"c e 0\",\n  \"pyramorphix\": \"t e 0\",\n  \"mastermorphix\": \"t e 0.346184634065199\",\n  \"pyraminx\": \"t v 0.333333333333333 v 1.66666666666667\",\n  \"master pyraminx\": \"t v 0 v 1 v 2\",\n  \"professor pyraminx\": \"t v -0.2 v 0.6 v 1.4 v 2.2\",\n  \"Jing pyraminx\": \"t f 0\",\n  \"master pyramorphix\": \"t e 0.866025403784437\",\n  \"megaminx\": \"d f 0.7\",\n  \"gigaminx\": \"d f 0.64 f 0.82\",\n  \"teraminx\": \"d f 0.64 f 0.76 f 0.88\",\n  \"petaminx\": \"d f 0.64 f 0.73 f 0.82 f 0.91\",\n  \"examinx\": \"d f 0.64 f 0.712 f 0.784 f 0.856 f 0.928\",\n  \"zetaminx\": \"d f 0.64 f 0.7 f 0.76 f 0.82 f 0.88 f 0.94\",\n  \"yottaminx\": \"d f 0.64 f 0.6914 f 0.7429 f 0.7943 f 0.8457 f 0.8971 f 0.9486\",\n  \"pentultimate\": \"d f 0\",\n  \"master pentultimate\": \"d f 0.1\",\n  // exact value for starminx is sqrt(5(5-2 sqrt(5))/3)\n  \"starminx\": \"d v 0.937962370425399\",\n  \"starminx 2\": \"d f 0.23606797749979\",\n  \"pyraminx crystal\": \"d f 0.447213595499989\",\n  \"chopasaurus\": \"d v 0\",\n  \"big chop\": \"d e 0\",\n  \"skewb diamond\": \"o f 0\",\n  \"FTO\": \"o f 0.333333333333333\",\n  \"Christopher's jewel\": \"o v 0.577350269189626\",\n  \"octastar\": \"o e 0\",\n  \"Trajber's octahedron\": \"o v 0.433012701892219\",\n  \"radio chop\": \"i f 0\",\n  \"icosamate\": \"i v 0\",\n  \"icosahedron 2\": \"i v 0.18759247376021\",\n  \"icosahedron 3\": \"i v 0.18759247376021 e 0\",\n  \"icosahedron static faces\": \"i v 0.84\",\n  \"icosahedron moving faces\": \"i v 0.73\",\n  \"Eitan's star\": \"i f 0.61803398874989\",\n  \"2x2x2 + dino\": \"c f 0 v 0.577350269189626\",\n  \"2x2x2 + little chop\": \"c f 0 e 0\",\n  \"dino + little chop\": \"c v 0.577350269189626 e 0\",\n  \"2x2x2 + dino + little chop\": \"c f 0 v 0.577350269189626 e 0\",\n  \"megaminx + chopasaurus\": \"d f 0.61803398875 v 0\",\n  \"starminx combo\": \"d f 0.23606797749979 v 0.937962370425399\",\n};\n\nexport type PuzzleName = keyof typeof PGPuzzles;\n","/* tslint:disable no-bitwise */\n/* tslint:disable prefer-for-of */ // TODO\n\n// We need a quaternion class.  We use this to represent rotations,\n// planes, and points.\n\nconst eps = 1e-9; // TODO: Deduplicate with `PuzzleGeometry`?\n\nexport function expandfaces(rots: Quat[], faces: Quat[][]): Quat[][] {\n  // given a set of faces, expand by rotation set\n  const nfaces = [];\n  for (let i = 0; i < rots.length; i++) {\n    for (let k = 0; k < faces.length; k++) {\n      const face = faces[k];\n      const nface = [];\n      for (let j = 0; j < face.length; j++) {\n        nface.push(face[j].rotateplane(rots[i]));\n      }\n      nfaces.push(nface);\n    }\n  }\n  return nfaces;\n}\n\nexport function centermassface(face: Quat[]): Quat {\n  // calculate a center of a face by averaging points\n  let s = new Quat(0, 0, 0, 0);\n  for (let i = 0; i < face.length; i++) {\n    s = s.sum(face[i]);\n  }\n  return s.smul(1.0 / face.length);\n}\n\nexport function random(): Quat {\n  // generate a random quat\n  const q = new Quat(\n    Math.random() * 2 - 1,\n    Math.random() * 2 - 1,\n    Math.random() * 2 - 1,\n    Math.random() * 2 - 1,\n  );\n  return q.smul(1 / q.len());\n}\n\nexport function solvethreeplanes(\n  p1: number,\n  p2: number,\n  p3: number,\n  planes: Quat[],\n): any {\n  // find intersection of three planes but only if interior\n  // Takes three indices into a plane array, and returns the point at the\n  // intersection of all three, but only if it is internal to all planes.\n  const p = planes[p1].intersect3(planes[p2], planes[p3]);\n  if (!p) {\n    return p;\n  }\n  for (let i = 0; i < planes.length; i++) {\n    if (i !== p1 && i !== p2 && i !== p3) {\n      const dt = planes[i].b * p.b + planes[i].c * p.c + planes[i].d * p.d;\n      if (\n        (planes[i].a > 0 && dt > planes[i].a) ||\n        (planes[i].a < 0 && dt < planes[i].a)\n      ) {\n        return false;\n      }\n    }\n  }\n  return p;\n}\n\nexport class FaceTree {\n  constructor(\n    public face: Quat[],\n    public left?: FaceTree,\n    public right?: FaceTree,\n  ) {}\n\n  public split(q: Quat): FaceTree {\n    const t = q.cutface(this.face);\n    if (t !== null) {\n      if (this.left === undefined) {\n        this.left = new FaceTree(t[0]);\n        this.right = new FaceTree(t[1]);\n      } else {\n        this.left = this.left?.split(q);\n        this.right = this.right?.split(q);\n      }\n    }\n    return this;\n  }\n\n  public collect(arr: Quat[][], leftfirst: boolean): Quat[][] {\n    if (this.left === undefined) {\n      arr.push(this.face);\n    } else if (leftfirst) {\n      this.left?.collect(arr, false);\n      this.right?.collect(arr, true);\n    } else {\n      this.right?.collect(arr, false);\n      this.left?.collect(arr, true);\n    }\n    return arr;\n  }\n}\n\nexport class Quat {\n  constructor(\n    public a: number,\n    public b: number,\n    public c: number,\n    public d: number,\n  ) {}\n\n  public mul(q: Quat): Quat {\n    // Quaternion multiplication\n    return new Quat(\n      this.a * q.a - this.b * q.b - this.c * q.c - this.d * q.d,\n      this.a * q.b + this.b * q.a + this.c * q.d - this.d * q.c,\n      this.a * q.c - this.b * q.d + this.c * q.a + this.d * q.b,\n      this.a * q.d + this.b * q.c - this.c * q.b + this.d * q.a,\n    );\n  }\n\n  public toString(): string {\n    return \"Q[\" + this.a + \",\" + this.b + \",\" + this.c + \",\" + this.d + \"]\";\n  }\n\n  public dist(q: Quat): number {\n    // Euclidean distance\n    return Math.hypot(this.a - q.a, this.b - q.b, this.c - q.c, this.d - q.d);\n  }\n\n  public len(): number {\n    // Euclidean length\n    return Math.hypot(this.a, this.b, this.c, this.d);\n  }\n\n  public cross(q: Quat): Quat {\n    // cross product\n    return new Quat(\n      0,\n      this.c * q.d - this.d * q.c,\n      this.d * q.b - this.b * q.d,\n      this.b * q.c - this.c * q.b,\n    );\n  }\n\n  public dot(q: Quat): number {\n    // dot product of two quaternions\n    return this.b * q.b + this.c * q.c + this.d * q.d;\n  }\n\n  public normalize(): Quat {\n    // make the magnitude be 1\n    const d = Math.sqrt(this.dot(this));\n    return new Quat(this.a / d, this.b / d, this.c / d, this.d / d);\n  }\n\n  public makenormal(): Quat {\n    // make a normal vector from a plane or quat or point\n    return new Quat(0, this.b, this.c, this.d).normalize();\n  }\n\n  public normalizeplane(): Quat {\n    // normalize a plane\n    const d = Math.hypot(this.b, this.c, this.d);\n    return new Quat(this.a / d, this.b / d, this.c / d, this.d / d);\n  }\n\n  public smul(m: number): Quat {\n    // scalar multiplication\n    return new Quat(this.a * m, this.b * m, this.c * m, this.d * m);\n  }\n\n  public sum(q: Quat): Quat {\n    // quaternion sum\n    return new Quat(this.a + q.a, this.b + q.b, this.c + q.c, this.d + q.d);\n  }\n\n  public sub(q: Quat): Quat {\n    // difference\n    return new Quat(this.a - q.a, this.b - q.b, this.c - q.c, this.d - q.d);\n  }\n\n  public angle(): number {\n    // quaternion angle\n    return 2 * Math.acos(this.a);\n  }\n\n  public invrot(): Quat {\n    // quaternion inverse rotation\n    return new Quat(this.a, -this.b, -this.c, -this.d);\n  }\n\n  public det3x3(\n    a00: number,\n    a01: number,\n    a02: number,\n    a10: number,\n    a11: number,\n    a12: number,\n    a20: number,\n    a21: number,\n    a22: number,\n  ): number {\n    // 3x3 determinant\n    return (\n      a00 * (a11 * a22 - a12 * a21) +\n      a01 * (a12 * a20 - a10 * a22) +\n      a02 * (a10 * a21 - a11 * a20)\n    );\n  }\n\n  public rotateplane(q: Quat): Quat {\n    // rotate a plane using a quaternion\n    const t = q.mul(new Quat(0, this.b, this.c, this.d)).mul(q.invrot());\n    t.a = this.a;\n    return t;\n  }\n\n  // return any vector orthogonal to the given one.  Find the smallest\n  // component (in absolute value) and return the cross product of that\n  // axis with the given vector.\n  public orthogonal(): Quat {\n    const ab = Math.abs(this.b);\n    const ac = Math.abs(this.c);\n    const ad = Math.abs(this.d);\n    if (ab < ac && ab < ad) {\n      return this.cross(new Quat(0, 1, 0, 0)).normalize();\n    } else if (ac < ab && ac < ad) {\n      return this.cross(new Quat(0, 0, 1, 0)).normalize();\n    } else {\n      return this.cross(new Quat(0, 0, 0, 1)).normalize();\n    }\n  }\n\n  // return the Quaternion that will rotate the this vector\n  // to the b vector through rotatepoint.\n  public pointrotation(b: Quat): Quat {\n    const a = this.normalize();\n    b = b.normalize();\n    if (a.sub(b).len() < eps) {\n      return new Quat(1, 0, 0, 0);\n    }\n    let h = a.sum(b);\n    if (h.len() < eps) {\n      h = h.orthogonal();\n    } else {\n      h = h.normalize();\n    }\n    const r = a.cross(h);\n    r.a = a.dot(h);\n    return r;\n  }\n\n  // given two vectors, return the portion of the first that\n  // is not in the direction of the second.\n  public unproject(b: Quat): Quat {\n    return this.sum(b.smul(-this.dot(b) / (this.len() * b.len())));\n  }\n\n  public rotatepoint(q: Quat): Quat {\n    // rotate a point\n    return q.mul(this).mul(q.invrot());\n  }\n\n  public rotateface(face: Quat[]): Quat[] {\n    // rotate a face by this Q.\n    return face.map((_: Quat) => _.rotatepoint(this));\n  }\n\n  public rotatecubie(cubie: Quat[][]): Quat[][] {\n    // rotate a cubie by this Q.\n    return cubie.map((_: Quat[]) => this.rotateface(_));\n  }\n\n  public intersect3(p2: Quat, p3: Quat): Quat | false {\n    // intersect three planes if there is one\n    const det = this.det3x3(\n      this.b,\n      this.c,\n      this.d,\n      p2.b,\n      p2.c,\n      p2.d,\n      p3.b,\n      p3.c,\n      p3.d,\n    );\n    if (Math.abs(det) < eps) {\n      return false; // TODO: Change to `null` or `undefined`?\n    }\n    return new Quat(\n      0,\n      this.det3x3(this.a, this.c, this.d, p2.a, p2.c, p2.d, p3.a, p3.c, p3.d) /\n        det,\n      this.det3x3(this.b, this.a, this.d, p2.b, p2.a, p2.d, p3.b, p3.a, p3.d) /\n        det,\n      this.det3x3(this.b, this.c, this.a, p2.b, p2.c, p2.a, p3.b, p3.c, p3.a) /\n        det,\n    );\n  }\n\n  public side(x: number): number {\n    // is this point close to the origin, or on one or the other side?\n    if (x > eps) {\n      return 1;\n    }\n    if (x < -eps) {\n      return -1;\n    }\n    return 0;\n  }\n\n  /**\n   * Cuts a face by this plane, or returns null if there\n   * is no intersection.\n   * @param face The face to cut.\n   */\n  public cutface(face: Quat[]): Quat[][] | null {\n    const d = this.a;\n    let seen = 0;\n    let r = null;\n    for (let i = 0; i < face.length; i++) {\n      seen |= 1 << (this.side(face[i].dot(this) - d) + 1);\n    }\n    if ((seen & 5) === 5) {\n      r = [];\n      // saw both sides\n      const inout = face.map((_: Quat) => this.side(_.dot(this) - d));\n      for (let s = -1; s <= 1; s += 2) {\n        const nface = [];\n        for (let k = 0; k < face.length; k++) {\n          if (inout[k] === s || inout[k] === 0) {\n            nface.push(face[k]);\n          }\n          const kk = (k + 1) % face.length;\n          if (inout[k] + inout[kk] === 0 && inout[k] !== 0) {\n            const vk = face[k].dot(this) - d;\n            const vkk = face[kk].dot(this) - d;\n            const r = vk / (vk - vkk);\n            const pt = face[k].smul(1 - r).sum(face[kk].smul(r));\n            nface.push(pt);\n          }\n        }\n        r.push(nface);\n      }\n    }\n    return r;\n  }\n\n  public cutfaces(faces: Quat[][]): Quat[][] {\n    // Cut a set of faces by a plane and return new set\n    const nfaces = [];\n    for (let j = 0; j < faces.length; j++) {\n      const face = faces[j];\n      const t = this.cutface(face);\n      if (t) {\n        nfaces.push(t[0]);\n        nfaces.push(t[1]);\n      } else {\n        nfaces.push(face);\n      }\n    }\n    return nfaces;\n  }\n\n  public faceside(face: Quat[]): number {\n    // which side of a plane is a face on?\n    const d = this.a;\n    for (let i = 0; i < face.length; i++) {\n      const s = this.side(face[i].dot(this) - d);\n      if (s !== 0) {\n        return s;\n      }\n    }\n    throw new Error(\"Could not determine side of plane in faceside\");\n  }\n\n  public sameplane(p: Quat): boolean {\n    // are two planes the same?\n    const a = this.normalize();\n    const b = p.normalize();\n    return a.dist(b) < eps || a.dist(b.smul(-1)) < eps;\n  }\n\n  public makecut(r: number): Quat {\n    // make a cut from a normal vector\n    return new Quat(r, this.b, this.c, this.d);\n  }\n}\n","/* tslint:disable prefer-for-of */ // TODO\n\nimport { Quat, solvethreeplanes } from \"./Quat\";\n\n// Next we define a class that yields quaternion generators for each of\n// the five platonic solids.  The quaternion generators chosen are\n// chosen specifically so that the first quaternion doubles as a plane\n// description that yields the given Platonic solid (so for instance, the\n// cubical group and octahedral group are identical in math, but we\n// give distinct representations choosing the first quaternion so that\n// we get the desired figure.)  Our convention is one vertex of the\n// shape points precisely down.\n\n// This class is static.\n\nconst eps = 1e-9; // TODO: Deduplicate with `PuzzleGeometry`?\n\nexport function cube(): Quat[] {\n  const s5 = Math.sqrt(0.5);\n  return [new Quat(s5, s5, 0, 0), new Quat(s5, 0, s5, 0)];\n}\n\nexport function tetrahedron(): Quat[] {\n  return [new Quat(0.5, 0.5, 0.5, 0.5), new Quat(0.5, 0.5, 0.5, -0.5)];\n}\n\nexport function dodecahedron(): Quat[] {\n  const d36 = (2 * Math.PI) / 10;\n  let dx = 0.5 + 0.3 * Math.sqrt(5);\n  let dy = 0.5 + 0.1 * Math.sqrt(5);\n  const dd = Math.sqrt(dx * dx + dy * dy);\n  dx /= dd;\n  dy /= dd;\n  return [\n    new Quat(Math.cos(d36), dx * Math.sin(d36), dy * Math.sin(d36), 0),\n    new Quat(0.5, 0.5, 0.5, 0.5),\n  ];\n}\n\nexport function icosahedron(): Quat[] {\n  let dx = 1 / 6 + Math.sqrt(5) / 6;\n  let dy = 2 / 3 + Math.sqrt(5) / 3;\n  const dd = Math.sqrt(dx * dx + dy * dy);\n  dx /= dd;\n  dy /= dd;\n  const ang = (2 * Math.PI) / 6;\n  return [\n    new Quat(Math.cos(ang), dx * Math.sin(ang), dy * Math.sin(ang), 0),\n    new Quat(Math.cos(ang), -dx * Math.sin(ang), dy * Math.sin(ang), 0),\n  ];\n}\n\nexport function octahedron(): Quat[] {\n  const s5 = Math.sqrt(0.5);\n  return [new Quat(0.5, 0.5, 0.5, 0.5), new Quat(s5, 0, 0, s5)];\n}\n\nexport function closure(g: Quat[]): Quat[] {\n  // compute the closure of a set of generators\n  // This is quadratic in the result size.  Also, it has no protection\n  // against you providing a bogus set of generators that would generate\n  // an infinite group.\n  const q = [new Quat(1, 0, 0, 0)];\n  for (let i = 0; i < q.length; i++) {\n    for (let j = 0; j < g.length; j++) {\n      const ns = g[j].mul(q[i]);\n      const negns = ns.smul(-1);\n      let wasseen = false;\n      for (let k = 0; k < q.length; k++) {\n        if (ns.dist(q[k]) < eps || negns.dist(q[k]) < eps) {\n          wasseen = true;\n          break;\n        }\n      }\n      if (!wasseen) {\n        q.push(ns);\n      }\n    }\n  }\n  return q;\n}\n\nexport function uniqueplanes(p: Quat, g: Quat[]): Quat[] {\n  // compute unique plane rotations\n  // given a rotation group and a plane, find the rotations that\n  // generate unique planes.  This is quadratic in the return size.\n  const planes = [];\n  const planerot = [];\n  for (let i = 0; i < g.length; i++) {\n    const p2 = p.rotateplane(g[i]);\n    let wasseen = false;\n    for (let j = 0; j < planes.length; j++) {\n      if (p2.dist(planes[j]) < eps) {\n        wasseen = true;\n        break;\n      }\n    }\n    if (!wasseen) {\n      planes.push(p2);\n      planerot.push(g[i]);\n    }\n  }\n  return planerot;\n}\n\nexport function getface(planes: Quat[]): Quat[] {\n  // compute a face given a set of planes\n  // The face returned will be a set of points that lie in the first plane\n  // in the given array, that are on the surface of the polytope defined\n  // by all the planes, and will be returned in clockwise order.\n  // This is O(planes^2 * return size + return_size^2).\n  const face = [];\n  for (let i = 1; i < planes.length; i++) {\n    for (let j = i + 1; j < planes.length; j++) {\n      const p = solvethreeplanes(0, i, j, planes);\n      if (p) {\n        let wasseen = false;\n        for (let k = 0; k < face.length; k++) {\n          if (p.dist(face[k]) < eps) {\n            wasseen = true;\n            break;\n          }\n        }\n        if (!wasseen) {\n          face.push(p);\n        }\n      }\n    }\n  }\n  for (;;) {\n    let changed = false;\n    for (let i = 0; i < face.length; i++) {\n      const j: number = (i + 1) % face.length;\n      if (planes[0].dot(face[i].cross(face[j])) < 0) {\n        const t: Quat = face[i];\n        face[i] = face[j];\n        face[j] = t;\n        changed = true;\n      }\n    }\n    if (!changed) {\n      break;\n    }\n  }\n  return face;\n}\n","/* tslint:disable no-bitwise */\n/* tslint:disable prefer-for-of */ // TODO\n/* tslint:disable only-arrow-functions */ // TODO\n/* tslint:disable typedef */ // TODO\n\nimport { Move, QuantumMove } from \"../alg\";\nimport { FaceNameSwizzler } from \"./FaceNameSwizzler\";\nimport {\n  MoveNotation,\n  PGVendoredKPuzzleDefinition,\n  Transformation as KTransformation,\n} from \"./interfaces\";\nimport {\n  FaceRenamingMapper,\n  FTONotationMapper,\n  MegaminxScramblingNotationMapper,\n  NotationMapper,\n  NullMapper,\n  NxNxNCubeMapper,\n  PyraminxNotationMapper,\n  SkewbNotationMapper,\n} from \"./NotationMapper\";\nimport { iota, Perm, zeros } from \"./Perm\";\nimport {\n  Orbit,\n  OrbitDef,\n  OrbitsDef,\n  showcanon,\n  Transformation,\n  VisibleState,\n} from \"./PermOriSet\";\nimport { PGPuzzles, PuzzleDescriptionString, PuzzleName } from \"./PGPuzzles\";\nimport {\n  closure,\n  cube,\n  dodecahedron,\n  getface,\n  icosahedron,\n  octahedron,\n  tetrahedron,\n  uniqueplanes,\n} from \"./PlatonicGenerator\";\nimport { centermassface, expandfaces, FaceTree, Quat } from \"./Quat\";\n\nconst DEFAULT_COLOR_FRACTION = 0.77;\n\nexport interface StickerDatSticker {\n  coords: number[][];\n  color: string;\n  orbit: string;\n  ord: number;\n  ori: number;\n}\n\nexport interface StickerDatFace {\n  coords: number[][];\n  name: string;\n}\n\nexport type StickerDatAxis = [number[], string, number];\n\nexport interface StickerDat {\n  stickers: StickerDatSticker[];\n  foundations: StickerDatSticker[];\n  faces: StickerDatFace[];\n  axis: StickerDatAxis[];\n  unswizzle(mv: Move): string;\n  notationMapper: NotationMapper;\n}\n\n// TODO: Remove this once we no longer have prefix restrictions.\nlet NEW_FACE_NAMES = true;\nexport function useNewFaceNames(use: boolean): void {\n  NEW_FACE_NAMES = use;\n}\n\n//  Now we have a geometry class that does the 3D goemetry to calculate\n//  individual sticker information from a Platonic solid and a set of\n//  cuts.  The cuts must have the same symmetry as the Platonic solid;\n//  we even restrict them further to be either vertex-normal,\n//  edge-normal, or face-parallel cuts.  Right now our constructor takes\n//  a character solid indicator (one of c(ube), o(ctahedron), i(cosahedron),\n//  t(etradron), or d(odecahedron), followed by an array of cuts.\n//  Each cut is a character normal indicator that is either f(ace),\n//  e(dge), or v(ertex), followed by a floating point value that gives\n//  the depth of the cut where 0 is the center and 1 is the outside\n//  border of the shape in that direction.\n\n//  This is a heavyweight class with lots of members and construction\n//  is slow.  Be gentle.\n\n//  Everything except a very few methods should be considered private.\n\nconst eps: number = 1e-9;\nconst copyright = \"PuzzleGeometry 0.1 Copyright 2018 Tomas Rokicki.\";\nconst permissivieMoveParsing = false;\n\n// This is a description of the nets and the external names we give each\n// face.  The names should be a set of prefix-free upper-case alphabetics\n// so\n// we can easily also name and distinguish vertices and edges, but we\n// may change this in the future.  The nets consist of a list of lists.\n// Each list gives the name of a face, and then the names of the\n// faces connected to that face (in the net) in clockwise order.\n// The length of each list should be one more than the number of\n// edges in the regular polygon for that face.  All polygons must\n// have the same number of edges.\n// The first two faces in the first list must describe a horizontal edge\n// that is at the bottom of a regular polygon.  The first two faces in\n// every subsequent list for a given polytope must describe a edge that\n// is directly connected in the net and has already been described (this\n// sets the location and orientation of the polygon for that face.\n// Any edge that is not directly connected in the net should be given\n// the empty string as the other face.  All faces do not need to have\n// a list starting with that face; just enough to describe the full\n// connectivity of the net.\n//\n// TODO: change this back to a const JSON definition.\nfunction defaultnets(): any {\n  return {\n    // four faces: tetrahedron\n    4: [[\"F\", \"D\", \"L\", \"R\"]],\n    // six faces: cube\n    6: [\n      [\"F\", \"D\", \"L\", \"U\", \"R\"],\n      [\"R\", \"F\", \"\", \"B\", \"\"],\n    ],\n    // eight faces: octahedron\n    8: [\n      [\"F\", \"D\", \"L\", \"R\"],\n      [\"D\", \"F\", \"BR\", \"\"],\n      [\"BR\", \"D\", \"\", \"BB\"],\n      [\"BB\", \"BR\", \"U\", \"BL\"],\n    ],\n    // twelve faces:  dodecahedron; U/F/R/F/BL/BR from megaminx\n    12: [\n      [\"U\", \"F\", \"\", \"\", \"\", \"\"],\n      [\"F\", \"U\", \"R\", \"C\", \"A\", \"L\"],\n      [\"R\", \"F\", \"\", \"\", \"E\", \"\"],\n      [\"E\", \"R\", \"\", \"BF\", \"\", \"\"],\n      [\"BF\", \"E\", \"BR\", \"BL\", \"I\", \"D\"],\n    ],\n    // twenty faces: icosahedron\n    20: [\n      [\"R\", \"C\", \"F\", \"E\"],\n      [\"F\", \"R\", \"L\", \"U\"],\n      [\"L\", \"F\", \"A\", \"\"],\n      [\"E\", \"R\", \"G\", \"I\"],\n      [\"I\", \"E\", \"S\", \"H\"],\n      [\"S\", \"I\", \"J\", \"B\"],\n      [\"B\", \"S\", \"K\", \"D\"],\n      [\"K\", \"B\", \"M\", \"O\"],\n      [\"O\", \"K\", \"P\", \"N\"],\n      [\"P\", \"O\", \"Q\", \"\"],\n    ],\n  };\n}\n\n// TODO: change this back to a const JSON definition.\nfunction defaultcolors(): any {\n  return {\n    // the colors should use the same naming convention as the nets, above.\n    4: { F: \"#00ff00\", D: \"#ffff00\", L: \"#ff0000\", R: \"#0000ff\" },\n    6: {\n      U: \"#ffffff\",\n      F: \"#00ff00\",\n      R: \"#ff0000\",\n      D: \"#ffff00\",\n      B: \"#0000ff\",\n      L: \"#ff8000\",\n    },\n    8: {\n      U: \"#ffffff\",\n      F: \"#ff0000\",\n      R: \"#00bb00\",\n      D: \"#ffff00\",\n      BB: \"#1122ff\",\n      L: \"#9524c5\",\n      BL: \"#ff8800\",\n      BR: \"#aaaaaa\",\n    },\n    12: {\n      U: \"#ffffff\",\n      F: \"#006633\",\n      R: \"#ff0000\",\n      C: \"#ffffd0\",\n      A: \"#3399ff\",\n      L: \"#660099\",\n      E: \"#ff66cc\",\n      BF: \"#99ff00\",\n      BR: \"#0000ff\",\n      BL: \"#ffff00\",\n      I: \"#ff6633\",\n      D: \"#999999\",\n    },\n    20: {\n      R: \"#db69f0\",\n      C: \"#178fde\",\n      F: \"#23238b\",\n      E: \"#9cc726\",\n      L: \"#2c212d\",\n      U: \"#177fa7\",\n      A: \"#e0de7f\",\n      G: \"#2b57c0\",\n      I: \"#41126b\",\n      S: \"#4b8c28\",\n      H: \"#7c098d\",\n      J: \"#7fe7b4\",\n      B: \"#85fb74\",\n      K: \"#3f4bc3\",\n      D: \"#0ff555\",\n      M: \"#f1c2c8\",\n      O: \"#58d340\",\n      P: \"#c514f2\",\n      N: \"#14494e\",\n      Q: \"#8b1be1\",\n    },\n  };\n}\n\n// the default precedence of the faces is given here.  This permits\n// the orientations to be reasonably predictable.  There are tradeoffs;\n// some face precedence orders do better things to the edge orientations\n// than the corner orientations and some are the opposite.\n// TODO: change this back to a const JSON definition.\nfunction defaultfaceorders(): any {\n  return {\n    4: [\"F\", \"D\", \"L\", \"R\"],\n    6: [\"U\", \"D\", \"F\", \"B\", \"L\", \"R\"],\n    8: [\"F\", \"BB\", \"D\", \"U\", \"BR\", \"L\", \"R\", \"BL\"],\n    12: [\"L\", \"E\", \"F\", \"BF\", \"R\", \"I\", \"U\", \"D\", \"BR\", \"A\", \"BL\", \"C\"],\n    20: [\n      \"L\",\n      \"S\",\n      \"E\",\n      \"O\",\n      \"F\",\n      \"B\",\n      \"I\",\n      \"P\",\n      \"R\",\n      \"K\",\n      \"U\",\n      \"D\",\n      \"J\",\n      \"A\",\n      \"Q\",\n      \"H\",\n      \"G\",\n      \"N\",\n      \"M\",\n      \"C\",\n    ],\n  };\n}\n\n/*\n *  Default orientations for the puzzles in 3D space.  Can be overridden\n *  by puzzleOrientation or puzzleOrientations options.\n *\n *  These are defined to have a strong intuitive vertical (y) direction\n *  since 3D orbital controls need this.  In comments, we list the\n *  preferred initial camera orientation for each puzzle for twizzle;\n *  this information is explicitly given in the twizzle app file.\n */\n// TODO: change this back to a const JSON definition.\nfunction defaultOrientations(): any {\n  return {\n    4: [\"FLR\", [0, 1, 0], \"F\", [0, 0, 1]], // FLR towards viewer\n    6: [\"U\", [0, 1, 0], \"F\", [0, 0, 1]], // URF towards viewer\n    8: [\"U\", [0, 1, 0], \"F\", [0, 0, 1]], // FLUR towards viewer\n    12: [\"U\", [0, 1, 0], \"F\", [0, 0, 1]], // F towards viewer\n    20: [\"GUQMJ\", [0, 1, 0], \"F\", [0, 0, 1]], // F towards viewer\n  };\n}\n\nfunction findelement(a: any[], p: Quat): number {\n  // find something in facenames, vertexnames, edgenames\n  for (let i = 0; i < a.length; i++) {\n    if (a[i][0].dist(p) < eps) {\n      return i;\n    }\n  }\n  throw new Error(\"Element not found\");\n}\n\nexport function getpuzzles(): { [s: string]: PuzzleDescriptionString } {\n  // get some simple definitions of basic puzzles\n  return PGPuzzles;\n}\n\nexport function getpuzzle(puzzleName: PuzzleName): PuzzleDescriptionString {\n  // get some simple definitions of basic puzzles\n  return PGPuzzles[puzzleName];\n}\n\nexport function parsedesc(s: string): any {\n  // parse a text description\n  const a = s.split(/ /).filter(Boolean);\n  if (a.length % 2 === 0) {\n    return false;\n  }\n  if (\n    a[0] !== \"o\" &&\n    a[0] !== \"c\" &&\n    a[0] !== \"i\" &&\n    a[0] !== \"d\" &&\n    a[0] !== \"t\"\n  ) {\n    return false;\n  }\n  const r = [];\n  for (let i = 1; i < a.length; i += 2) {\n    if (a[i] !== \"f\" && a[i] !== \"v\" && a[i] !== \"e\") {\n      return false;\n    }\n    r.push([a[i], a[i + 1]]);\n  }\n  return [a[0], r];\n}\n\nexport function getPuzzleGeometryByDesc(\n  desc: string,\n  options: string[] = [],\n): PuzzleGeometry {\n  const [shape, cuts] = parsedesc(desc);\n  const pg = new PuzzleGeometry(\n    shape,\n    cuts,\n    [\"allmoves\", \"true\"].concat(options),\n  );\n  pg.allstickers();\n  pg.genperms();\n  return pg;\n}\n\nexport function getPuzzleGeometryByName(\n  puzzleName: PuzzleName,\n  options: string[] = [],\n): PuzzleGeometry {\n  return getPuzzleGeometryByDesc(PGPuzzles[puzzleName], options);\n}\n\nfunction getmovename(geo: any, bits: number[], slices: number): any {\n  // generate a move name based on bits, slice, and geo\n  // if the move name is from the opposite face, say so.\n  // find the face that's turned.\n  let inverted = false;\n  if (slices - bits[1] < bits[0]) {\n    // flip if most of the move is on the other side\n    geo = [geo[2], geo[3], geo[0], geo[1]];\n    bits = [slices - bits[1], slices - bits[0]];\n    inverted = true;\n  }\n  let movenameFamily = geo[0];\n  let movenamePrefix = \"\";\n  if (bits[0] === 0 && bits[1] === slices) {\n    movenameFamily = movenameFamily + \"v\";\n  } else if (bits[0] === bits[1]) {\n    if (bits[1] > 0) {\n      movenamePrefix = String(bits[1] + 1);\n    }\n  } else if (bits[0] === 0) {\n    movenameFamily = movenameFamily.toLowerCase();\n    if (bits[1] > 1) {\n      movenamePrefix = String(bits[1] + 1);\n    }\n  } else {\n    throw \"We only support slice and outer block moves right now. \" + bits;\n  }\n  return [movenamePrefix + movenameFamily, inverted];\n}\n\n// split a geometrical element into face names.  Do greedy match.\n// Permit underscores between names.\nfunction splitByFaceNames(s: string, facenames: any[]): string[] {\n  const r: string[] = [];\n  let at = 0;\n  while (at < s.length) {\n    if (at > 0 && at < s.length && s[at] === \"_\") {\n      at++;\n    }\n    let currentMatch = \"\";\n    for (let i = 0; i < facenames.length; i++) {\n      if (\n        s.substr(at).startsWith(facenames[i][1]) &&\n        facenames[i][1].length > currentMatch.length\n      ) {\n        currentMatch = facenames[i][1];\n      }\n    }\n    if (currentMatch !== \"\") {\n      r.push(currentMatch);\n      at += currentMatch.length;\n    } else {\n      throw new Error(\"Could not split \" + s + \" into face names.\");\n    }\n  }\n  return r;\n}\n\nfunction toCoords(q: Quat, maxdist: number): number[] {\n  return [q.b / maxdist, -q.c / maxdist, q.d / maxdist];\n}\n\nfunction toFaceCoords(q: Quat[], maxdist: number): number[][] {\n  const r = [];\n  const n = q.length;\n  for (let i = 0; i < n; i++) {\n    r[n - i - 1] = toCoords(q[i], maxdist);\n  }\n  return r;\n}\n\nfunction trimEdges(face: Quat[], tr: number): Quat[] {\n  const r: Quat[] = [];\n  for (let iter = 1; iter < 10; iter++) {\n    for (let i = 0; i < face.length; i++) {\n      const pi = (i + face.length - 1) % face.length;\n      const ni = (i + 1) % face.length;\n      const A = face[pi].sub(face[i]).normalize();\n      const B = face[ni].sub(face[i]).normalize();\n      const d = A.dot(B);\n      const m = tr / Math.sqrt(1 - d * d);\n      r[i] = face[i].sum(A.sum(B).smul(m));\n    }\n    let good = true;\n    for (let i = 0; good && i < r.length; i++) {\n      const pi = (i + face.length - 1) % face.length;\n      const ni = (i + 1) % face.length;\n      if (r[pi].sub(r[i]).cross(r[ni].sub(r[i])).dot(r[i]) >= 0) {\n        good = false;\n      }\n    }\n    if (good) {\n      return r;\n    }\n    tr /= 2;\n  }\n  return face;\n}\n\nexport class PuzzleGeometry {\n  public args: string = \"\";\n  public rotations: Quat[]; // all members of the rotation group\n  public baseplanerot: Quat[]; // unique rotations of the baseplane\n  public baseplanes: Quat[]; // planes, corresponding to faces\n  public facenames: any[]; // face names\n  public faceplanes: any; // face planes\n  public edgenames: any[]; // edge names\n  public vertexnames: any[]; // vertexnames\n  public geonormals: any[]; // all geometric directions, with names and types\n  public moveplanes: Quat[]; // the planes that split moves\n  public moveplanes2: Quat[]; // the planes that split moves, filtered\n  public moveplanesets: any[]; // the move planes, in parallel sets\n  public moveplanenormals: Quat[]; // one move plane\n  public movesetorders: any[]; // the order of rotations for each move set\n  public movesetgeos: any[]; // geometric feature information for move sets\n  public basefaces: Quat[][]; // polytope faces before cuts\n  public faces: Quat[][]; // all the stickers\n  public facecentermass: Quat[]; // center of mass of all faces\n  public basefacecount: number; // number of base faces\n  public stickersperface: number; // number of stickers per face\n  public cornerfaces: number; // number of faces that meet at a corner\n  public cubies: any[]; // the cubies\n  public shortedge: number; // shortest edge\n  public vertexdistance: number; // vertex distance\n  public edgedistance: number; // edge distance\n  public orbits: number; // count of cubie orbits\n  public facetocubies: any[]; // map a face to a cubie index and offset\n  public moverotations: Quat[][]; // move rotations\n  public cubiekey: any; // cubie locator\n  public cubiekeys: string[]; // cubie keys\n  public facelisthash: any; // face list by key\n  public cubiesetnames: any[]; // cubie set names\n  public cubieords: number[]; // the size of each orbit\n  public cubiesetnums: number[];\n  public cubieordnums: number[];\n  public orbitoris: number[]; // the orientation size of each orbit\n  public cubievaluemap: number[]; // the map for identical cubies\n  public cubiesetcubies: number[][]; // cubies in each cubie set\n  public cmovesbyslice: number[][][] = []; // cmoves as perms by slice\n  // options\n  public verbose: number = 0; // verbosity (console.log)\n  public allmoves: boolean = false; // generate all slice moves in ksolve\n  public outerblockmoves: boolean; // generate outer block moves\n  public vertexmoves: boolean; // generate vertex moves\n  public addrotations: boolean; // add symmetry information to ksolve output\n  public movelist: any; // move list to generate\n  public parsedmovelist: any; // parsed move list\n  public puzzleOrientation: any; // single puzzle orientation from options\n  public puzzleOrientations: any; // puzzle orientation override list from options\n  public cornersets: boolean = true; // include corner sets\n  public centersets: boolean = true; // include center sets\n  public edgesets: boolean = true; // include edge sets\n  public graycorners: boolean = false; // make corner sets gray\n  public graycenters: boolean = false; // make center sets gray\n  public grayedges: boolean = false; // make edge sets gray\n  public killorientation: boolean = false; // eliminate any orientations\n  public optimize: boolean = false; // optimize PermOri\n  public scramble: number = 0; // scramble?\n  public ksolvemovenames: string[]; // move names from ksolve\n  public fixPiece: string = \"\"; // fix a piece?\n  public orientCenters: boolean = false; // orient centers?\n  public duplicatedFaces: number[] = []; // which faces are duplicated\n  public duplicatedCubies: number[] = []; // which cubies are duplicated\n  public fixedCubie: number = -1; // fixed cubie, if any\n  public svggrips: any[]; // grips from svg generation by svg coordinate\n  public net: any = [];\n  public colors: any = [];\n  public faceorder: any = [];\n  public faceprecedence: number[] = [];\n  public swizzler: FaceNameSwizzler;\n  public notationMapper: NotationMapper = new NullMapper();\n  public addNotationMapper: string = \"\";\n  public setReidOrder: boolean = false;\n  constructor(shape: string, cuts: string[][], optionlist: any[] | undefined) {\n    function asstructured(v: any): any {\n      if (typeof v === \"string\") {\n        return JSON.parse(v);\n      }\n      return v;\n    }\n    function asboolean(v: any): boolean {\n      if (typeof v === \"string\") {\n        if (v === \"false\") {\n          return false;\n        }\n        return true;\n      } else {\n        return v ? true : false;\n      }\n    }\n    if (optionlist !== undefined) {\n      if (optionlist.length % 2 !== 0) {\n        throw new Error(\"Odd length in option list?\");\n      }\n      for (let i = 0; i < optionlist.length; i += 2) {\n        if (optionlist[i] === \"verbose\") {\n          this.verbose++;\n        } else if (optionlist[i] === \"quiet\") {\n          this.verbose = 0;\n        } else if (optionlist[i] === \"allmoves\") {\n          this.allmoves = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"outerblockmoves\") {\n          this.outerblockmoves = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"vertexmoves\") {\n          this.vertexmoves = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"rotations\") {\n          this.addrotations = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"cornersets\") {\n          this.cornersets = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"centersets\") {\n          this.centersets = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"edgesets\") {\n          this.edgesets = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"graycorners\") {\n          this.graycorners = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"graycenters\") {\n          this.graycenters = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"grayedges\") {\n          this.grayedges = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"movelist\") {\n          this.movelist = asstructured(optionlist[i + 1]);\n        } else if (optionlist[i] === \"killorientation\") {\n          this.killorientation = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"optimize\") {\n          this.optimize = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"scramble\") {\n          this.scramble = optionlist[i + 1];\n        } else if (optionlist[i] === \"fix\") {\n          this.fixPiece = optionlist[i + 1];\n        } else if (optionlist[i] === \"orientcenters\") {\n          this.orientCenters = asboolean(optionlist[i + 1]);\n        } else if (optionlist[i] === \"puzzleorientation\") {\n          this.puzzleOrientation = asstructured(optionlist[i + 1]);\n        } else if (optionlist[i] === \"puzzleorientations\") {\n          this.puzzleOrientations = asstructured(optionlist[i + 1]);\n        } else {\n          throw new Error(\n            \"Bad option while processing option list \" + optionlist[i],\n          );\n        }\n      }\n    }\n    this.args = shape + \" \" + cuts.map((_) => _.join(\" \")).join(\" \");\n    if (optionlist) {\n      this.args += \" \" + optionlist.join(\" \");\n    }\n    if (this.verbose > 0) {\n      console.log(this.header(\"# \"));\n    }\n    this.create(shape, cuts);\n  }\n\n  public create(shape: string, cuts: any[]): void {\n    // create the shape, doing all the essential geometry\n    // create only goes far enough to figure out how many stickers per\n    // face, and what the short edge is.  If the short edge is too short,\n    // we probably don't want to display or manipulate this one.  How\n    // short is too short is hard to say.\n    // var that = this ; // TODO\n    this.moveplanes = [];\n    this.moveplanes2 = [];\n    this.faces = [];\n    this.cubies = [];\n    let g = null;\n    switch (shape) {\n      case \"c\":\n        g = cube();\n        break;\n      case \"o\":\n        g = octahedron();\n        break;\n      case \"i\":\n        g = icosahedron();\n        break;\n      case \"t\":\n        g = tetrahedron();\n        break;\n      case \"d\":\n        g = dodecahedron();\n        break;\n      default:\n        throw new Error(\"Bad shape argument: \" + shape);\n    }\n    this.rotations = closure(g);\n    if (this.verbose) {\n      console.log(\"# Rotations: \" + this.rotations.length);\n    }\n    const baseplane = g[0];\n    this.baseplanerot = uniqueplanes(baseplane, this.rotations);\n    const baseplanes = this.baseplanerot.map((_) => baseplane.rotateplane(_));\n    this.baseplanes = baseplanes;\n    this.basefacecount = baseplanes.length;\n    const net = defaultnets()[baseplanes.length];\n    this.net = net;\n    this.colors = defaultcolors()[baseplanes.length];\n    this.faceorder = defaultfaceorders()[baseplanes.length];\n    if (this.verbose) {\n      console.log(\"# Base planes: \" + baseplanes.length);\n    }\n    const baseface = getface(baseplanes);\n    const zero = new Quat(0, 0, 0, 0);\n    if (this.verbose) {\n      console.log(\"# Face vertices: \" + baseface.length);\n    }\n    const facenormal = baseplanes[0].makenormal();\n    const edgenormal = baseface[0].sum(baseface[1]).makenormal();\n    const vertexnormal = baseface[0].makenormal();\n    const boundary = new Quat(1, facenormal.b, facenormal.c, facenormal.d);\n    if (this.verbose) {\n      console.log(\"# Boundary is \" + boundary);\n    }\n    const planerot = uniqueplanes(boundary, this.rotations);\n    const planes = planerot.map((_) => boundary.rotateplane(_));\n    let faces = [getface(planes)];\n    this.edgedistance = faces[0][0].sum(faces[0][1]).smul(0.5).dist(zero);\n    this.vertexdistance = faces[0][0].dist(zero);\n    const cutplanes = [];\n    const intersects = [];\n    let sawface = false; // what cuts did we see?\n    let sawedge = false;\n    let sawvertex = false;\n    for (let i = 0; i < cuts.length; i++) {\n      let normal = null;\n      let distance = 0;\n      switch (cuts[i][0]) {\n        case \"f\":\n          normal = facenormal;\n          distance = 1;\n          sawface = true;\n          break;\n        case \"v\":\n          normal = vertexnormal;\n          distance = this.vertexdistance;\n          sawvertex = true;\n          break;\n        case \"e\":\n          normal = edgenormal;\n          distance = this.edgedistance;\n          sawedge = true;\n          break;\n        default:\n          throw new Error(\"Bad cut argument: \" + cuts[i][0]);\n      }\n      cutplanes.push(normal.makecut(Number(cuts[i][1])));\n      intersects.push(cuts[i][1] < distance);\n    }\n    if (this.addrotations) {\n      if (!sawface) {\n        cutplanes.push(facenormal.makecut(10));\n      }\n      if (!sawvertex) {\n        cutplanes.push(vertexnormal.makecut(10));\n      }\n      if (!sawedge) {\n        cutplanes.push(edgenormal.makecut(10));\n      }\n    }\n    this.basefaces = [];\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(faces[0]);\n      this.basefaces.push(face);\n    }\n    //\n    //   Determine names for edges, vertices, and planes.  Planes are defined\n    //   by the plane normal/distance; edges are defined by the midpoint;\n    //   vertices are defined by actual point.  In each case we define a name.\n    //   Note that edges have two potential names, and corners have n where\n    //   n planes meet at a vertex.  We arbitrarily choose the one that is\n    //   alphabetically first (and we will probably want to change this).\n    //\n    const facenames: any[] = [];\n    const faceplanes = [];\n    const vertexnames: any[] = [];\n    const edgenames: any[] = [];\n    const edgesperface = faces[0].length;\n    function searchaddelement(a: any[], p: Quat, name: any): void {\n      for (let i = 0; i < a.length; i++) {\n        if (a[i][0].dist(p) < eps) {\n          a[i].push(name);\n          return;\n        }\n      }\n      a.push([p, name]);\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(faces[0]);\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        searchaddelement(edgenames, midpoint, i);\n      }\n    }\n    const otherfaces = [];\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(faces[0]);\n      const facelist = [];\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        const el = edgenames[findelement(edgenames, midpoint)];\n        if (i === el[1]) {\n          facelist.push(el[2]);\n        } else if (i === el[2]) {\n          facelist.push(el[1]);\n        } else {\n          throw new Error(\"Could not find edge\");\n        }\n      }\n      otherfaces.push(facelist);\n    }\n    const facenametoindex: any = {};\n    const faceindextoname: any = [];\n    faceindextoname.push(net[0][0]);\n    facenametoindex[net[0][0]] = 0;\n    faceindextoname[otherfaces[0][0]] = net[0][1];\n    facenametoindex[net[0][1]] = otherfaces[0][0];\n    for (let i = 0; i < net.length; i++) {\n      const f0 = net[i][0];\n      const fi = facenametoindex[f0];\n      if (fi === undefined) {\n        throw new Error(\"Bad edge description; first edge not connected\");\n      }\n      let ii = -1;\n      for (let j = 0; j < otherfaces[fi].length; j++) {\n        const fn2 = faceindextoname[otherfaces[fi][j]];\n        if (fn2 !== undefined && fn2 === net[i][1]) {\n          ii = j;\n          break;\n        }\n      }\n      if (ii < 0) {\n        throw new Error(\"First element of a net not known\");\n      }\n      for (let j = 2; j < net[i].length; j++) {\n        if (net[i][j] === \"\") {\n          continue;\n        }\n        const of = otherfaces[fi][(j + ii - 1) % edgesperface];\n        const fn2 = faceindextoname[of];\n        if (fn2 !== undefined && fn2 !== net[i][j]) {\n          throw new Error(\"Face mismatch in net\");\n        }\n        faceindextoname[of] = net[i][j];\n        facenametoindex[net[i][j]] = of;\n      }\n    }\n    for (let i = 0; i < faceindextoname.length; i++) {\n      let found = false;\n      for (let j = 0; j < this.faceorder.length; j++) {\n        if (faceindextoname[i] === this.faceorder[j]) {\n          this.faceprecedence[i] = j;\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        throw new Error(\n          \"Could not find face \" +\n            faceindextoname[i] +\n            \" in face order list \" +\n            this.faceorder,\n        );\n      }\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(faces[0]);\n      const faceplane = boundary.rotateplane(this.baseplanerot[i]);\n      const facename = faceindextoname[i];\n      facenames.push([face, facename]);\n      faceplanes.push([faceplane, facename]);\n    }\n    for (let i = 0; i < this.baseplanerot.length; i++) {\n      const face = this.baseplanerot[i].rotateface(faces[0]);\n      const facename = faceindextoname[i];\n      for (let j = 0; j < face.length; j++) {\n        const jj = (j + 1) % face.length;\n        const midpoint = face[j].sum(face[jj]).smul(0.5);\n        const jjj = (j + 2) % face.length;\n        const midpoint2 = face[jj].sum(face[jjj]).smul(0.5);\n        const e1 = findelement(edgenames, midpoint);\n        const e2 = findelement(edgenames, midpoint2);\n        searchaddelement(vertexnames, face[jj], [facename, e2, e1]);\n      }\n    }\n    this.swizzler = new FaceNameSwizzler(facenames.map((_: any) => _[1]));\n    const sep = this.swizzler.prefixFree ? \"\" : \"_\";\n    // fix the edge names; use face precedence order\n    for (let i = 0; i < edgenames.length; i++) {\n      if (edgenames[i].length !== 3) {\n        throw new Error(\"Bad length in edge names \" + edgenames[i]);\n      }\n      let c1 = faceindextoname[edgenames[i][1]];\n      const c2 = faceindextoname[edgenames[i][2]];\n      if (\n        this.faceprecedence[edgenames[i][1]] <\n        this.faceprecedence[edgenames[i][2]]\n      ) {\n        c1 = c1 + sep + c2;\n      } else {\n        c1 = c2 + sep + c1;\n      }\n      edgenames[i] = [edgenames[i][0], c1];\n    }\n    // fix the vertex names; counterclockwise rotations; low face first.\n    this.cornerfaces = vertexnames[0].length - 1;\n    for (let i = 0; i < vertexnames.length; i++) {\n      if (vertexnames[i].length < 4) {\n        throw new Error(\"Bad length in vertex names\");\n      }\n      let st = 1;\n      for (let j = 2; j < vertexnames[i].length; j++) {\n        if (\n          this.faceprecedence[facenametoindex[vertexnames[i][j][0]]] <\n          this.faceprecedence[facenametoindex[vertexnames[i][st][0]]]\n        ) {\n          st = j;\n        }\n      }\n      let r = \"\";\n      for (let j = 1; j < vertexnames[i].length; j++) {\n        if (j === 1) {\n          r = vertexnames[i][st][0];\n        } else {\n          r = r + sep + vertexnames[i][st][0];\n        }\n        for (let k = 1; k < vertexnames[i].length; k++) {\n          if (vertexnames[i][st][1] === vertexnames[i][k][2]) {\n            st = k;\n            break;\n          }\n        }\n      }\n      vertexnames[i] = [vertexnames[i][0], r];\n    }\n    if (this.verbose > 1) {\n      console.log(\"# Face precedence list: \" + this.faceorder.join(\" \"));\n      console.log(\"# Face names: \" + facenames.map((_: any) => _[1]).join(\" \"));\n      console.log(\"# Edge names: \" + edgenames.map((_: any) => _[1]).join(\" \"));\n      console.log(\n        \"# Vertex names: \" + vertexnames.map((_: any) => _[1]).join(\" \"),\n      );\n    }\n    const geonormals = [];\n    for (let i = 0; i < faceplanes.length; i++) {\n      geonormals.push([faceplanes[i][0].makenormal(), faceplanes[i][1], \"f\"]);\n    }\n    for (let i = 0; i < edgenames.length; i++) {\n      geonormals.push([edgenames[i][0].makenormal(), edgenames[i][1], \"e\"]);\n    }\n    for (let i = 0; i < vertexnames.length; i++) {\n      geonormals.push([vertexnames[i][0].makenormal(), vertexnames[i][1], \"v\"]);\n    }\n    this.facenames = facenames;\n    this.faceplanes = faceplanes;\n    this.edgenames = edgenames;\n    this.vertexnames = vertexnames;\n    this.geonormals = geonormals;\n    const geonormalnames = geonormals.map((_: any) => _[1]);\n    this.swizzler.setGripNames(geonormalnames);\n    if (this.verbose) {\n      console.log(\n        \"# Distances: face \" +\n          1 +\n          \" edge \" +\n          this.edgedistance +\n          \" vertex \" +\n          this.vertexdistance,\n      );\n    }\n    // expand cutplanes by rotations.  We only work with one face here.\n    for (let c = 0; c < cutplanes.length; c++) {\n      for (let i = 0; i < this.rotations.length; i++) {\n        const q = cutplanes[c].rotateplane(this.rotations[i]);\n        let wasseen = false;\n        for (let j = 0; j < this.moveplanes.length; j++) {\n          if (q.sameplane(this.moveplanes[j])) {\n            wasseen = true;\n            break;\n          }\n        }\n        if (!wasseen) {\n          this.moveplanes.push(q);\n          if (intersects[c]) {\n            this.moveplanes2.push(q);\n          }\n        }\n      }\n    }\n    let ft = new FaceTree(faces[0]);\n    const tar = this.moveplanes2.slice();\n    // we want to use Math.random() here but we can't, because when\n    // we call multiple times we'll get different orbits/layouts.\n    // to resolve this, we use a very simple linear congruential\n    // generator.  for our purposes, the numbers don't need to be\n    // very random.\n    let rval = 31;\n    for (let i = 0; i < tar.length; i++) {\n      const j = i + Math.floor((tar.length - i) * (rval / 65536.0));\n      ft = ft.split(tar[j]);\n      tar[j] = tar[i];\n      rval = (rval * 1657 + 101) % 65536;\n    }\n    faces = ft.collect([], true);\n    this.faces = faces;\n    if (this.verbose) {\n      console.log(\"# Faces is now \" + faces.length);\n    }\n    this.stickersperface = faces.length;\n    //  Find and report the shortest edge in any of the faces.  If this\n    //  is small the puzzle is probably not practical or displayable.\n    let shortedge = 1e99;\n    for (let i = 0; i < faces.length; i++) {\n      for (let j = 0; j < faces[i].length; j++) {\n        const k = (j + 1) % faces[i].length;\n        const t = faces[i][j].dist(faces[i][k]);\n        if (t < shortedge) {\n          shortedge = t;\n        }\n      }\n    }\n    this.shortedge = shortedge;\n    if (this.verbose) {\n      console.log(\"# Short edge is \" + shortedge);\n    }\n    // add nxnxn cube notation if it has cube face moves\n    if (shape === \"c\" && sawface && !sawedge && !sawvertex) {\n      // In this case the mapper adding is deferred until we\n      // know the number of slices.\n      this.addNotationMapper = \"NxNxNCubeMapper\";\n      // try to set Reid order of the cubies within an orbit\n      this.setReidOrder = true;\n    }\n    if (shape === \"c\" && sawvertex && !sawface && !sawedge) {\n      this.addNotationMapper = \"SkewbMapper\";\n    }\n    if (shape === \"t\" && (sawvertex || sawface) && !sawedge) {\n      this.addNotationMapper = \"PyraminxMapper\";\n    }\n    if (shape === \"o\" && sawface && NEW_FACE_NAMES) {\n      this.notationMapper = new FaceRenamingMapper(\n        this.swizzler,\n        new FaceNameSwizzler([\"F\", \"D\", \"L\", \"BL\", \"R\", \"U\", \"BR\", \"B\"]),\n      );\n      if (!sawedge && !sawvertex) {\n        this.addNotationMapper = \"FTOMapper\";\n      }\n    }\n    if (shape === \"d\" && sawface && NEW_FACE_NAMES) {\n      this.addNotationMapper = \"MegaminxMapper\";\n      this.notationMapper = new FaceRenamingMapper(\n        this.swizzler,\n        new FaceNameSwizzler([\n          \"U\",\n          \"F\",\n          \"L\",\n          \"BL\",\n          \"BR\",\n          \"R\",\n          \"FR\",\n          \"FL\",\n          \"DL\",\n          \"B\",\n          \"DR\",\n          \"D\",\n        ]),\n      );\n    }\n  }\n\n  public keyface(face: Quat[]): string {\n    return this.keyface2(centermassface(face));\n  }\n\n  public keyface2(cm: Quat): string {\n    // take a face and figure out the sides of each move plane\n    let s = \"\";\n    for (let i = 0; i < this.moveplanesets.length; i++) {\n      if (this.moveplanesets[i].length > 0) {\n        const dv = cm.dot(this.moveplanesets[i][0]);\n        let t = 0;\n        let b = 1;\n        while (b * 2 <= this.moveplanesets[i].length) {\n          b *= 2;\n        }\n        for (; b > 0; b >>= 1) {\n          if (\n            t + b <= this.moveplanesets[i].length &&\n            dv > this.moveplanesets[i][t + b - 1].a\n          ) {\n            t += b;\n          }\n        }\n        s = s + \" \" + t;\n      }\n    }\n    return s;\n  }\n\n  public findface(face: Quat[]): number {\n    const cm = centermassface(face);\n    const key = this.keyface2(cm);\n    const arr = this.facelisthash[key];\n    if (arr.length === 1) {\n      return arr[0];\n    }\n    for (let i = 0; i + 1 < arr.length; i++) {\n      const face2 = this.facelisthash[key][i];\n      if (Math.abs(cm.dist(this.facecentermass[face2])) < eps) {\n        return face2;\n      }\n    }\n    return arr[arr.length - 1];\n  }\n\n  public findface2(cm: Quat): number {\n    const key = this.keyface2(cm);\n    const arr = this.facelisthash[key];\n    if (arr.length === 1) {\n      return arr[0];\n    }\n    for (let i = 0; i + 1 < arr.length; i++) {\n      const face2 = this.facelisthash[key][i];\n      if (Math.abs(cm.dist(this.facecentermass[face2])) < eps) {\n        return face2;\n      }\n    }\n    return arr[arr.length - 1];\n  }\n\n  public project2d(facen: number, edgen: number, targvec: Quat[]): any {\n    // calculate geometry to map a particular edge of a particular\n    //  face to a given 2D vector.  The face is given as an index into the\n    //  facenames/baseplane arrays, and the edge is given as an offset into\n    //  the vertices.\n    const face = this.facenames[facen][0];\n    const edgen2 = (edgen + 1) % face.length;\n    const plane = this.baseplanes[facen];\n    let x0 = face[edgen2].sub(face[edgen]);\n    const olen = x0.len();\n    x0 = x0.normalize();\n    const y0 = x0.cross(plane).normalize();\n    let delta = targvec[1].sub(targvec[0]);\n    const len = delta.len() / olen;\n    delta = delta.normalize();\n    const cosr = delta.b;\n    const sinr = delta.c;\n    const x1 = x0.smul(cosr).sub(y0.smul(sinr)).smul(len);\n    const y1 = y0.smul(cosr).sum(x0.smul(sinr)).smul(len);\n    const off = new Quat(\n      0,\n      targvec[0].b - x1.dot(face[edgen]),\n      targvec[0].c - y1.dot(face[edgen]),\n      0,\n    );\n    return [x1, y1, off];\n  }\n\n  public allstickers(): void {\n    // next step is to calculate all the stickers and orbits\n    // We do enough work here to display the cube on the screen.\n    // take our newly split base face and expand it by the rotation matrix.\n    // this generates our full set of \"stickers\".\n    this.faces = expandfaces(this.baseplanerot, this.faces);\n    if (this.verbose) {\n      console.log(\"# Total stickers is now \" + this.faces.length);\n    }\n    this.facecentermass = new Array(this.faces.length);\n    for (let i = 0; i < this.faces.length; i++) {\n      this.facecentermass[i] = centermassface(this.faces[i]);\n    }\n    // Split moveplanes into a list of parallel planes.\n    const moveplanesets: Quat[][] = [];\n    const moveplanenormals: Quat[] = [];\n    // get the normals, first, from unfiltered moveplanes.\n    for (let i = 0; i < this.moveplanes.length; i++) {\n      const q = this.moveplanes[i];\n      const qnormal = q.makenormal();\n      let wasseen = false;\n      for (let j = 0; j < moveplanenormals.length; j++) {\n        if (qnormal.sameplane(moveplanenormals[j].makenormal())) {\n          wasseen = true;\n        }\n      }\n      if (!wasseen) {\n        moveplanenormals.push(qnormal);\n        moveplanesets.push([]);\n      }\n    }\n    for (let i = 0; i < this.moveplanes2.length; i++) {\n      const q = this.moveplanes2[i];\n      const qnormal = q.makenormal();\n      for (let j = 0; j < moveplanenormals.length; j++) {\n        if (qnormal.sameplane(moveplanenormals[j])) {\n          moveplanesets[j].push(q);\n          break;\n        }\n      }\n    }\n    // make the normals all face the same way in each set.\n    for (let i = 0; i < moveplanesets.length; i++) {\n      const q: Quat[] = moveplanesets[i].map((_) => _.normalizeplane());\n      const goodnormal = moveplanenormals[i];\n      for (let j = 0; j < q.length; j++) {\n        if (q[j].makenormal().dist(goodnormal) > eps) {\n          q[j] = q[j].smul(-1);\n        }\n      }\n      q.sort((a, b) => a.a - b.a);\n      moveplanesets[i] = q;\n    }\n    this.moveplanesets = moveplanesets;\n    this.moveplanenormals = moveplanenormals;\n    const sizes = moveplanesets.map((_) => _.length);\n    if (this.verbose) {\n      console.log(\"# Move plane sets: \" + sizes);\n    }\n    // for each of the move planes, find the rotations that are relevant\n    const moverotations: Quat[][] = [];\n    for (let i = 0; i < moveplanesets.length; i++) {\n      moverotations.push([]);\n    }\n    for (let i = 0; i < this.rotations.length; i++) {\n      const q: Quat = this.rotations[i];\n      if (Math.abs(Math.abs(q.a) - 1) < eps) {\n        continue;\n      }\n      const qnormal = q.makenormal();\n      for (let j = 0; j < moveplanesets.length; j++) {\n        if (qnormal.sameplane(moveplanenormals[j])) {\n          moverotations[j].push(q);\n          break;\n        }\n      }\n    }\n    this.moverotations = moverotations;\n    //  Sort the rotations by the angle of rotation.  A bit tricky because\n    //  while the norms should be the same, they need not be.  So we start\n    //  by making the norms the same, and then sorting.\n    for (let i = 0; i < moverotations.length; i++) {\n      const r = moverotations[i];\n      const goodnormal = r[0].makenormal();\n      for (let j = 0; j < r.length; j++) {\n        if (goodnormal.dist(r[j].makenormal()) > eps) {\n          r[j] = r[j].smul(-1);\n        }\n      }\n      r.sort((a, b) => a.angle() - b.angle());\n      if (moverotations[i][0].dot(moveplanenormals[i]) < 0) {\n        r.reverse();\n      }\n    }\n    const sizes2 = moverotations.map((_) => 1 + _.length);\n    this.movesetorders = sizes2;\n    const movesetgeos = [];\n    let gtype = \"?\";\n    for (let i = 0; i < moveplanesets.length; i++) {\n      const p0 = moveplanenormals[i];\n      let neg = null;\n      let pos = null;\n      for (let j = 0; j < this.geonormals.length; j++) {\n        const d = p0.dot(this.geonormals[j][0]);\n        if (Math.abs(d - 1) < eps) {\n          pos = [this.geonormals[j][1], this.geonormals[j][2]];\n          gtype = this.geonormals[j][2];\n        } else if (Math.abs(d + 1) < eps) {\n          neg = [this.geonormals[j][1], this.geonormals[j][2]];\n          gtype = this.geonormals[j][2];\n        }\n      }\n      if (pos === null || neg === null) {\n        throw new Error(\"Saw positive or negative sides as null\");\n      }\n      movesetgeos.push([\n        pos[0],\n        pos[1],\n        neg[0],\n        neg[1],\n        1 + moveplanesets[i].length,\n      ]);\n      if (this.addNotationMapper === \"NxNxNCubeMapper\" && gtype === \"f\") {\n        this.notationMapper = new NxNxNCubeMapper(1 + moveplanesets[i].length);\n        this.addNotationMapper = \"\";\n      }\n      if (\n        this.addNotationMapper === \"SkewbMapper---DISABLED\" &&\n        moveplanesets[0].length === 1\n      ) {\n        this.notationMapper = new SkewbNotationMapper(this.swizzler);\n        this.addNotationMapper = \"\";\n      }\n      if (\n        this.addNotationMapper === \"PyraminxMapper---DISABLED\" &&\n        moveplanesets[0].length === 2\n      ) {\n        this.notationMapper = new PyraminxNotationMapper(this.swizzler);\n        this.addNotationMapper = \"\";\n      }\n      if (this.addNotationMapper === \"MegaminxMapper\" && gtype === \"f\") {\n        if (1 + moveplanesets[i].length === 3) {\n          this.notationMapper = new MegaminxScramblingNotationMapper(\n            this.notationMapper,\n          );\n        }\n        this.addNotationMapper = \"\";\n      }\n      if (this.addNotationMapper === \"FTOMapper\" && gtype === \"f\") {\n        if (1 + moveplanesets[i].length === 3) {\n          this.notationMapper = new FTONotationMapper(\n            this.notationMapper,\n            this.swizzler,\n          );\n        }\n        this.addNotationMapper = \"\";\n      }\n    }\n    this.movesetgeos = movesetgeos;\n    //  Cubies are split by move plane sets.  For each cubie we can\n    //  average its points to find a point on the interior of that\n    //  cubie.  We can then check that point against all the move\n    //  planes and from that derive a coordinate for the cubie.\n    //  This also works for faces; no face should ever lie on a move\n    //  plane.  This allows us to take a set of stickers and break\n    //  them up into cubie sets.\n    const cubiehash: any = {};\n    const facelisthash: any = {};\n    const cubiekey: any = {};\n    const cubiekeys = [];\n    const cubies: Quat[][][] = [];\n    const faces = this.faces;\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i];\n      const s = this.keyface(face);\n      if (!cubiehash[s]) {\n        cubiekey[s] = cubies.length;\n        cubiekeys.push(s);\n        cubiehash[s] = [];\n        facelisthash[s] = [];\n        cubies.push(cubiehash[s]);\n      }\n      facelisthash[s].push(i);\n      cubiehash[s].push(face);\n      //  If we find a core cubie, split it up into multiple cubies,\n      //  because ksolve doesn't handle orientations that are not\n      //  cyclic, and the rotation group of the core is not cyclic.\n      if (facelisthash[s].length === this.basefacecount) {\n        if (this.verbose) {\n          console.log(\"# Splitting core.\");\n        }\n        for (let suff = 0; suff < this.basefacecount; suff++) {\n          const s2 = s + \" \" + suff;\n          facelisthash[s2] = [facelisthash[s][suff]];\n          cubiehash[s2] = [cubiehash[s][suff]];\n          cubiekeys.push(s2);\n          cubiekey[s2] = cubies.length;\n          cubies.push(cubiehash[s2]);\n        }\n        cubiehash[s] = [];\n        cubies[cubiekey[s]] = [];\n      }\n    }\n    this.cubiekey = cubiekey;\n    this.facelisthash = facelisthash;\n    this.cubiekeys = cubiekeys;\n    if (this.verbose) {\n      console.log(\"# Cubies: \" + Object.keys(cubiehash).length);\n    }\n    //  Sort the faces around each corner so they are counterclockwise.  Only\n    //  relevant for cubies that actually are corners (three or more\n    //  faces).  In general cubies might have many faces; for icosohedrons\n    //  there are five faces on the corner cubies.\n    this.cubies = cubies;\n    for (let k = 0; k < cubies.length; k++) {\n      const cubie = cubies[k];\n      if (cubie.length < 2) {\n        continue;\n      }\n      if (cubie.length === this.basefacecount) {\n        // looks like core?  don't sort\n        continue;\n      }\n      if (cubie.length > 5) {\n        throw new Error(\n          \"Bad math; too many faces on this cubie \" + cubie.length,\n        );\n      }\n      const cm = cubie.map((_) => centermassface(_));\n      const s = this.keyface2(cm[0]);\n      const facelist = facelisthash[s];\n      const cmall = centermassface(cm);\n      for (let looplimit = 0; cubie.length > 2; looplimit++) {\n        let changed = false;\n        for (let i = 0; i < cubie.length; i++) {\n          const j = (i + 1) % cubie.length;\n          // var ttt = cmall.dot(cm[i].cross(cm[j])) ; // TODO\n          if (cmall.dot(cm[i].cross(cm[j])) < 0) {\n            const t = cubie[i];\n            cubie[i] = cubie[j];\n            cubie[j] = t;\n            const u = cm[i];\n            cm[i] = cm[j];\n            cm[j] = u;\n            const v = facelist[i];\n            facelist[i] = facelist[j];\n            facelist[j] = v;\n            changed = true;\n          }\n        }\n        if (!changed) {\n          break;\n        }\n        if (looplimit > 1000) {\n          throw new Error(\"Bad epsilon math; too close to border\");\n        }\n      }\n      let mini = 0;\n      let minf = this.findface(cubie[mini]);\n      for (let i = 1; i < cubie.length; i++) {\n        const temp = this.findface(cubie[i]);\n        if (\n          this.faceprecedence[this.getfaceindex(temp)] <\n          this.faceprecedence[this.getfaceindex(minf)]\n        ) {\n          mini = i;\n          minf = temp;\n        }\n      }\n      if (mini !== 0) {\n        const ocubie = cubie.slice();\n        const ofacelist = facelist.slice();\n        for (let i = 0; i < cubie.length; i++) {\n          cubie[i] = ocubie[(mini + i) % cubie.length];\n          facelist[i] = ofacelist[(mini + i) % cubie.length];\n        }\n      }\n    }\n    //  Build an array that takes each face to a cubie ordinal and a\n    //  face number.\n    const facetocubies = [];\n    for (let i = 0; i < cubies.length; i++) {\n      const facelist = facelisthash[cubiekeys[i]];\n      for (let j = 0; j < facelist.length; j++) {\n        facetocubies[facelist[j]] = [i, j];\n      }\n    }\n    this.facetocubies = facetocubies;\n    //  Calculate the orbits of each cubie.  Assumes we do all moves.\n    //  Also calculates which cubies are identical.\n    const typenames = [\"?\", \"CENTERS\", \"EDGES\", \"CORNERS\", \"C4RNER\", \"C5RNER\"];\n    const cubiesetnames = [];\n    const cubietypecounts = [0, 0, 0, 0, 0, 0];\n    const orbitoris = [];\n    const seen = [];\n    let cubiesetnum = 0;\n    const cubiesetnums = [];\n    const cubieordnums = [];\n    const cubieords = [];\n    // var cubiesetnumhash = {} ; // TODO\n    const cubievaluemap = [];\n    // Later we will make this smarter to use a get color for face function\n    // so we support puzzles with multiple faces the same color\n    const getcolorkey = (cubienum: number): string => {\n      return cubies[cubienum]\n        .map((_) => this.getfaceindex(this.findface(_)))\n        .join(\" \");\n    };\n    const cubiesetcubies: any = [];\n    for (let i = 0; i < cubies.length; i++) {\n      if (seen[i]) {\n        continue;\n      }\n      const cubie = cubies[i];\n      if (cubie.length === 0) {\n        continue;\n      }\n      const cubiekeymap: any = {};\n      let cubievalueid = 0;\n      cubieords.push(0);\n      cubiesetcubies.push([]);\n      const facecnt = cubie.length;\n      const typectr = cubietypecounts[facecnt]++;\n      let typename = typenames[facecnt];\n      if (typename === undefined || facecnt === this.basefacecount) {\n        typename = \"CORE\";\n      }\n      typename = typename + (typectr === 0 ? \"\" : typectr + 1);\n      cubiesetnames[cubiesetnum] = typename;\n      orbitoris[cubiesetnum] = facecnt;\n      const queue = [i];\n      let qg = 0;\n      seen[i] = true;\n      while (qg < queue.length) {\n        const cind = queue[qg++];\n        const cubiecolorkey = getcolorkey(cind);\n        if (cubie.length > 1 || cubiekeymap[cubiecolorkey] === undefined) {\n          cubiekeymap[cubiecolorkey] = cubievalueid++;\n        }\n        cubievaluemap[cind] = cubiekeymap[cubiecolorkey];\n        cubiesetnums[cind] = cubiesetnum;\n        cubiesetcubies[cubiesetnum].push(cind);\n        cubieordnums[cind] = cubieords[cubiesetnum]++;\n        const cm = centermassface(cubies[cind][0]);\n        if (queue.length < this.rotations.length) {\n          for (let j = 0; j < moverotations.length; j++) {\n            const tq = this.facetocubies[\n              this.findface2(cm.rotatepoint(moverotations[j][0]))\n            ][0];\n            if (!seen[tq]) {\n              queue.push(tq);\n              seen[tq] = true;\n            }\n          }\n        }\n      }\n      cubiesetnum++;\n    }\n    if (\n      this.setReidOrder &&\n      4 <= this.stickersperface &&\n      this.stickersperface <= 9\n    ) {\n      const reidorder = [\n        [\n          \"UF\",\n          \"UR\",\n          \"UB\",\n          \"UL\",\n          \"DF\",\n          \"DR\",\n          \"DB\",\n          \"DL\",\n          \"FR\",\n          \"FL\",\n          \"BR\",\n          \"BL\",\n        ],\n        [\"UFR\", \"URB\", \"UBL\", \"ULF\", \"DRF\", \"DFL\", \"DLB\", \"DBR\"],\n        [\"U\", \"L\", \"F\", \"R\", \"B\", \"D\"],\n      ];\n      const reidmap: { [key: number]: number } = {};\n      for (let i = 0; i < reidorder.length; i++) {\n        for (let j = 0; j < reidorder[i].length; j++) {\n          let mask = 0;\n          for (let k = 0; k < reidorder[i][j].length; k++) {\n            mask |= 1 << (reidorder[i][j].charCodeAt(k) - 65);\n          }\n          reidmap[mask] = j;\n        }\n      }\n      for (let i = 0; i < cubiesetnum; i++) {\n        for (let j = 0; j < cubiesetcubies[i].length; j++) {\n          const cubienum = cubiesetcubies[i][j];\n          let mask = 0;\n          for (let k = 0; k < cubies[cubienum].length; k++) {\n            mask |=\n              1 <<\n              (this.facenames[\n                this.getfaceindex(this.findface(cubies[cubienum][k]))\n              ][1].charCodeAt(0) -\n                65);\n          }\n          cubieordnums[cubienum] = reidmap[mask];\n        }\n      }\n    }\n    this.orbits = cubieords.length;\n    this.cubiesetnums = cubiesetnums;\n    this.cubieordnums = cubieordnums;\n    this.cubiesetnames = cubiesetnames;\n    this.cubieords = cubieords;\n    this.orbitoris = orbitoris;\n    this.cubievaluemap = cubievaluemap;\n    this.cubiesetcubies = cubiesetcubies;\n    // if we fix a cubie, find a cubie to fix\n    if (this.fixPiece !== \"\") {\n      for (let i = 0; i < cubies.length; i++) {\n        if (\n          (this.fixPiece === \"v\" && cubies[i].length > 2) ||\n          (this.fixPiece === \"e\" && cubies[i].length === 2) ||\n          (this.fixPiece === \"f\" && cubies[i].length === 1)\n        ) {\n          this.fixedCubie = i;\n          break;\n        }\n      }\n      if (this.fixedCubie < 0) {\n        throw new Error(\n          \"Could not find a cubie of type \" + this.fixPiece + \" to fix.\",\n        );\n      }\n    }\n    // show the orbits\n    if (this.verbose) {\n      console.log(\"# Cubie orbit sizes \" + cubieords);\n    }\n  }\n\n  public unswizzle(mv: Move): string {\n    const newmv = this.notationMapper.notationToInternal(mv);\n    if (newmv === null) {\n      return \"\";\n    }\n    return this.swizzler.unswizzle(newmv.family);\n  }\n\n  // We use an extremely permissive parse here; any character but\n  // digits are allowed in a family name.\n  public stringToBlockMove(mv: string): Move {\n    // parse a move from the command line\n    const re = RegExp(\"^(([0-9]+)-)?([0-9]+)?([^0-9]+)([0-9]+'?)?$\");\n    const p = mv.match(re);\n    if (p === null) {\n      throw new Error(\"Bad move passed \" + mv);\n    }\n    const grip = p[4];\n    let loslice = undefined;\n    let hislice = undefined;\n    if (p[2] !== undefined) {\n      if (p[3] === undefined) {\n        throw new Error(\"Missing second number in range\");\n      }\n      loslice = parseInt(p[2], 10);\n    }\n    if (p[3] !== undefined) {\n      hislice = parseInt(p[3], 10);\n    }\n    let amountstr = \"1\";\n    let amount = 1;\n    if (p[5] !== undefined) {\n      amountstr = p[5];\n      if (amountstr[0] === \"'\") {\n        amountstr = \"-\" + amountstr.substring(1);\n      }\n      amount = parseInt(amountstr, 10);\n    }\n    return new Move(new QuantumMove(grip, hislice, loslice), amount);\n  }\n\n  public parseMove(move: Move): any {\n    const bm = this.notationMapper.notationToInternal(move); // pluggable notation\n    if (bm === null) {\n      throw new Error(\"Bad move \" + move.family);\n    }\n    move = bm;\n    let grip = move.family;\n    let fullrotation = false;\n    if (grip.endsWith(\"v\") && grip[0] <= \"Z\") {\n      if (move.innerLayer !== undefined || move.outerLayer !== undefined) {\n        throw new Error(\"Cannot use a prefix with full cube rotations\");\n      }\n      grip = grip.slice(0, -1);\n      fullrotation = true;\n    }\n    if (grip.endsWith(\"w\") && grip[0] <= \"Z\") {\n      grip = grip.slice(0, -1).toLowerCase();\n    }\n    let geo;\n    let msi = -1;\n    const geoname = this.swizzler.unswizzle(grip);\n    let firstgrip = false;\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const g = this.movesetgeos[i];\n      if (geoname === g[0]) {\n        firstgrip = true;\n        geo = g;\n        msi = i;\n      }\n      if (geoname === g[2]) {\n        firstgrip = false;\n        geo = g;\n        msi = i;\n      }\n    }\n    let loslice = 1;\n    let hislice = 1;\n    if (grip.toUpperCase() !== grip) {\n      hislice = 2;\n    }\n    if (geo === undefined) {\n      throw new Error(\"Bad grip in move \" + move.family);\n    }\n    if (move.outerLayer !== undefined) {\n      loslice = move.outerLayer;\n    }\n    if (move.innerLayer !== undefined) {\n      if (move.outerLayer === undefined) {\n        hislice = move.innerLayer;\n        if (geoname === grip) {\n          loslice = hislice;\n        } else {\n          loslice = 1;\n        }\n      } else {\n        hislice = move.innerLayer;\n      }\n    }\n    loslice--;\n    hislice--;\n    if (fullrotation) {\n      loslice = 0;\n      hislice = this.moveplanesets[msi].length;\n    }\n    if (\n      loslice < 0 ||\n      loslice > this.moveplanesets[msi].length ||\n      hislice < 0 ||\n      hislice > this.moveplanesets[msi].length\n    ) {\n      throw new Error(\"Bad slice spec \" + loslice + \" \" + hislice);\n    }\n    if (\n      !permissivieMoveParsing &&\n      loslice === 0 &&\n      hislice === this.moveplanesets[msi].length &&\n      !fullrotation\n    ) {\n      throw new Error(\n        \"! full puzzle rotations must be specified with v suffix.\",\n      );\n    }\n    const r = [\n      undefined,\n      msi,\n      loslice,\n      hislice,\n      firstgrip,\n      move.effectiveAmount,\n    ];\n    return r;\n  }\n\n  public parsemove(mv: string): any {\n    const r = this.parseMove(this.stringToBlockMove(mv));\n    r[0] = mv;\n    return r;\n  }\n\n  public genperms(): void {\n    // generate permutations for moves\n    if (this.cmovesbyslice.length > 0) {\n      // did this already?\n      return;\n    }\n    const cmovesbyslice = [];\n    // if orientCenters is set, we find all cubies that have only one\n    // sticker and that sticker is in the center of a face, and we\n    // introduce duplicate stickers so we can orient them properly.\n    if (this.orientCenters) {\n      for (let k = 0; k < this.cubies.length; k++) {\n        if (this.cubies[k].length === 1) {\n          const kk = this.findface(this.cubies[k][0]);\n          const i = this.getfaceindex(kk);\n          if (\n            centermassface(this.basefaces[i]).dist(this.facecentermass[kk]) <\n            eps\n          ) {\n            const o = this.basefaces[i].length;\n            for (let m = 0; m < o; m++) {\n              this.cubies[k].push(this.cubies[k][0]);\n            }\n            this.duplicatedFaces[kk] = o;\n            this.duplicatedCubies[k] = o;\n            this.orbitoris[this.cubiesetnums[k]] = o;\n          }\n        }\n      }\n    }\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveplaneset = this.moveplanesets[k];\n      const slicenum = [];\n      const slicecnts = [moveplaneset.length + 1, 0];\n      let bhi = 1;\n      while (bhi * 2 <= moveplaneset.length) {\n        bhi *= 2;\n      }\n      for (let i = 0; i < this.faces.length; i++) {\n        let t = 0;\n        if (moveplaneset.length > 0) {\n          const dv = this.facecentermass[i].dot(moveplaneset[0]);\n          for (let b = bhi; b > 0; b >>= 1) {\n            if (\n              t + b <= moveplaneset.length &&\n              dv > moveplaneset[t + b - 1].a\n            ) {\n              t += b;\n            }\n          }\n          t = moveplaneset.length - t;\n        }\n        slicenum.push(t);\n        while (slicecnts.length <= t) {\n          slicecnts.push(0);\n        }\n        slicecnts[t]++;\n      }\n      const axiscmoves = new Array(slicecnts.length);\n      for (let sc = 0; sc < slicecnts.length; sc++) {\n        axiscmoves[sc] = [];\n      }\n      const cubiedone = [];\n      for (let i = 0; i < this.faces.length; i++) {\n        if (slicenum[i] < 0) {\n          continue;\n        }\n        const b = this.facetocubies[i].slice();\n        let cm = this.facecentermass[i];\n        const ocm = cm;\n        let fi2 = i;\n        const sc = slicenum[fi2];\n        for (;;) {\n          slicenum[fi2] = -1;\n          const cm2 = cm.rotatepoint(this.moverotations[k][0]);\n          if (cm2.dist(ocm) < eps) {\n            break;\n          }\n          fi2 = this.findface2(cm2);\n          const c = this.facetocubies[fi2];\n          b.push(c[0], c[1]);\n          cm = cm2;\n        }\n        // If an oriented center is moving, we need to figure out\n        // the appropriate new orientation.  Normally we use the cubie\n        // sticker identity to locate, but this doesn't work here.\n        // Instead we need to redo the geometry of the sticker itself\n        // rotating and figure out how that maps to the destination\n        // sticker.\n        //\n        // We only need to do this for central center stickers: those\n        // where the face vertex goes through the center.  The others\n        // don't actually need orientation because they can only be\n        // in one orientation by physical constraints.  (You can't spin\n        // a point or cross sticker on the 5x5x5, for example.)\n        //\n        // This also simplifies things because it means the actual\n        // remapping has the same order as the moves themselves.\n        //\n        // The center may or may not have been duplicated at this point.\n        //\n        // The move moving the center might not be the same modulo as the\n        // center itself.\n        if (\n          b.length > 2 &&\n          this.orientCenters &&\n          (this.cubies[b[0]].length === 1 ||\n            this.cubies[b[0]][0] === this.cubies[b[0]][1])\n        ) {\n          // is this a real center cubie, around an axis?\n          if (\n            this.facecentermass[i].dist(\n              centermassface(this.basefaces[this.getfaceindex(i)]),\n            ) < eps\n          ) {\n            // how does remapping of the face/point set map to the original?\n            let face1 = this.cubies[b[0]][0];\n            for (let ii = 0; ii < b.length; ii += 2) {\n              const face0 = this.cubies[b[ii]][0];\n              let o = -1;\n              for (let jj = 0; jj < face1.length; jj++) {\n                if (face0[jj].dist(face1[0]) < eps) {\n                  o = jj;\n                  break;\n                }\n              }\n              if (o < 0) {\n                throw new Error(\n                  \"Couldn't find rotation of center faces; ignoring for now.\",\n                );\n              } else {\n                b[ii + 1] = o;\n                face1 = this.moverotations[k][0].rotateface(face1);\n              }\n            }\n          }\n        }\n        // b.length == 2 means a sticker is spinning in place.\n        // in this case we add duplicate stickers\n        // so that we can make it animate properly in a 3D world.\n        if (b.length === 2 && this.orientCenters) {\n          for (let ii = 1; ii < this.movesetorders[k]; ii++) {\n            if (sc === 0) {\n              b.push(b[0], ii);\n            } else {\n              b.push(\n                b[0],\n                (this.movesetorders[k] - ii) % this.movesetorders[k],\n              );\n            }\n          }\n        }\n        if (b.length > 2 && !cubiedone[b[0]]) {\n          if (b.length !== 2 * this.movesetorders[k]) {\n            throw new Error(\"Bad length in perm gen\");\n          }\n          for (let j = 0; j < b.length; j++) {\n            axiscmoves[sc].push(b[j]);\n          }\n        }\n        for (let j = 0; j < b.length; j += 2) {\n          cubiedone[b[j]] = true;\n        }\n      }\n      cmovesbyslice.push(axiscmoves);\n    }\n    this.cmovesbyslice = cmovesbyslice;\n    if (this.movelist !== undefined) {\n      const parsedmovelist: any[] = [];\n      // make sure the movelist makes sense based on the geos.\n      for (let i = 0; i < this.movelist.length; i++) {\n        parsedmovelist.push(this.parsemove(this.movelist[i]));\n      }\n      this.parsedmovelist = parsedmovelist;\n    }\n    this.facelisthash = null;\n    this.facecentermass = [];\n    this.cubiekey = [];\n  }\n\n  public getfaces(): number[][][] {\n    // get the faces for 3d.\n    return this.faces.map((_) => {\n      return _.map((__) => [__.b, __.c, __.d]);\n    });\n  }\n\n  public getboundarygeometry(): any {\n    // get the boundary geometry\n    return {\n      baseplanes: this.baseplanes,\n      facenames: this.facenames,\n      faceplanes: this.faceplanes,\n      vertexnames: this.vertexnames,\n      edgenames: this.edgenames,\n      geonormals: this.geonormals,\n    };\n  }\n\n  public getmovesets(k: number): any {\n    // get the move sets we support based on slices\n    // for even values we omit the middle \"slice\".  This isn't perfect\n    // but it is what we do for now.\n    // if there was a move list specified, pull values from that\n    const slices = this.moveplanesets[k].length;\n    let r = [];\n    if (this.parsedmovelist !== undefined) {\n      for (let i = 0; i < this.parsedmovelist.length; i++) {\n        const parsedmove = this.parsedmovelist[i];\n        if (parsedmove[1] !== k) {\n          continue;\n        }\n        if (parsedmove[4]) {\n          r.push([parsedmove[2], parsedmove[3]]);\n        } else {\n          r.push([slices - parsedmove[3], slices - parsedmove[2]]);\n        }\n        r.push(parsedmove[5]);\n      }\n    } else if (this.vertexmoves && !this.allmoves) {\n      const msg = this.movesetgeos[k];\n      if (msg[1] !== msg[3]) {\n        for (let i = 0; i < slices; i++) {\n          if (msg[1] !== \"v\") {\n            if (this.outerblockmoves) {\n              r.push([i + 1, slices]);\n            } else {\n              r.push([i + 1]);\n            }\n            r.push(1);\n          } else {\n            if (this.outerblockmoves) {\n              r.push([0, i]);\n            } else {\n              r.push([i, i]);\n            }\n            r.push(1);\n          }\n        }\n      }\n    } else {\n      for (let i = 0; i <= slices; i++) {\n        if (!this.allmoves && i + i === slices) {\n          continue;\n        }\n        if (this.outerblockmoves) {\n          if (i + i > slices) {\n            r.push([i, slices]);\n          } else {\n            r.push([0, i]);\n          }\n        } else {\n          r.push([i, i]);\n        }\n        r.push(1);\n      }\n    }\n    if (this.addrotations && !this.allmoves) {\n      r.push([0, slices]);\n      r.push(1);\n    }\n    if (this.fixedCubie >= 0) {\n      const dep = +this.cubiekeys[this.fixedCubie].trim().split(\" \")[k];\n      const newr = [];\n      for (let i = 0; i < r.length; i += 2) {\n        let o = r[i];\n        if (dep >= o[0] && dep <= o[1]) {\n          if (o[0] === 0) {\n            o = [o[1] + 1, slices];\n          } else if (slices === o[1]) {\n            o = [0, o[0] - 1];\n          } else {\n            throw Error(\"fixed cubie option would disconnect move\");\n          }\n        }\n        let found = false;\n        for (let j = 0; j < newr.length; j += 2) {\n          if (\n            newr[j][0] === o[0] &&\n            newr[j][1] === o[1] &&\n            newr[j + 1] === r[i + 1]\n          ) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          newr.push(o);\n          newr.push(r[i + 1]);\n        }\n      }\n      r = newr;\n    }\n    return r;\n  }\n\n  public graybyori(cubie: number): boolean {\n    let ori = this.cubies[cubie].length;\n    if (this.duplicatedCubies[cubie]) {\n      ori = 1;\n    }\n    return (\n      (ori === 1 && (this.graycenters || !this.centersets)) ||\n      (ori === 2 && (this.grayedges || !this.edgesets)) ||\n      (ori > 2 && (this.graycorners || !this.cornersets))\n    );\n  }\n\n  public skipbyori(cubie: number): boolean {\n    let ori = this.cubies[cubie].length;\n    if (this.duplicatedCubies[cubie]) {\n      ori = 1;\n    }\n    return (\n      (ori === 1 && !this.centersets) ||\n      (ori === 2 && !this.edgesets) ||\n      (ori > 2 && !this.cornersets)\n    );\n  }\n\n  public skipcubie(fi: number): boolean {\n    return this.skipbyori(fi);\n  }\n\n  public skipset(set: number[]): boolean {\n    if (set.length === 0) {\n      return true;\n    }\n    const fi = set[0];\n    return this.skipbyori(this.facetocubies[fi][0]);\n  }\n\n  public header(comment: string): string {\n    return comment + copyright + \"\\n\" + comment + this.args + \"\\n\";\n  }\n\n  public writegap(): string {\n    // write out a gap set of generators\n    const os = this.getOrbitsDef(false);\n    const r = [];\n    const mvs = [];\n    for (let i = 0; i < os.moveops.length; i++) {\n      const movename = \"M_\" + os.movenames[i];\n      // gap doesn't like angle brackets in IDs\n      mvs.push(movename);\n      r.push(movename + \":=\" + os.moveops[i].toPerm().toGap() + \";\");\n    }\n    r.push(\"Gen:=[\");\n    r.push(mvs.join(\",\"));\n    r.push(\"];\");\n    const ip = os.solved.identicalPieces();\n    r.push(\n      \"ip:=[\" +\n        ip.map((_) => \"[\" + _.map((__) => __ + 1).join(\",\") + \"]\").join(\",\") +\n        \"];\",\n    );\n    r.push(\"\");\n    return this.header(\"# \") + r.join(\"\\n\");\n  }\n\n  public writeksolve(\n    name: string = \"PuzzleGeometryPuzzle\",\n    fortwisty: boolean = false,\n  ): string {\n    const od = this.getOrbitsDef(fortwisty);\n    if (fortwisty) {\n      return od.toKsolve(name, fortwisty).join(\"\\n\");\n    } else {\n      return this.header(\"# \") + od.toKsolve(name, fortwisty).join(\"\\n\");\n    }\n  }\n\n  public writekpuzzle(fortwisty: boolean = true): PGVendoredKPuzzleDefinition {\n    const od = this.getOrbitsDef(fortwisty);\n    const r = od.toKpuzzle() as PGVendoredKPuzzleDefinition;\n    r.moveNotation = new PGNotation(this, od);\n    return r;\n  }\n\n  public getMoveFromBits(\n    moverange: number[],\n    amount: number,\n    inverted: boolean,\n    axiscmoves: number[][],\n    setmoves: number[] | undefined,\n    movesetorder: number,\n  ): Transformation {\n    const moveorbits: Orbit[] = [];\n    const perms = [];\n    const oris = [];\n    for (let ii = 0; ii < this.cubiesetnames.length; ii++) {\n      perms.push(iota(this.cubieords[ii]));\n      oris.push(zeros(this.cubieords[ii]));\n    }\n    for (let m = moverange[0]; m <= moverange[1]; m++) {\n      const slicecmoves = axiscmoves[m];\n      for (let j = 0; j < slicecmoves.length; j += 2 * movesetorder) {\n        const mperm = slicecmoves.slice(j, j + 2 * movesetorder);\n        const setnum = this.cubiesetnums[mperm[0]];\n        for (let ii = 0; ii < mperm.length; ii += 2) {\n          mperm[ii] = this.cubieordnums[mperm[ii]];\n        }\n        let inc = 2;\n        let oinc = 3;\n        if (inverted) {\n          inc = mperm.length - 2;\n          oinc = mperm.length - 1;\n        }\n        if (perms[setnum] === iota(this.cubieords[setnum])) {\n          perms[setnum] = perms[setnum].slice();\n          if (this.orbitoris[setnum] > 1 && !this.killorientation) {\n            oris[setnum] = oris[setnum].slice();\n          }\n        }\n        for (let ii = 0; ii < mperm.length; ii += 2) {\n          perms[setnum][mperm[(ii + inc) % mperm.length]] = mperm[ii];\n          if (this.orbitoris[setnum] > 1 && !this.killorientation) {\n            oris[setnum][mperm[ii]] =\n              (mperm[(ii + oinc) % mperm.length] -\n                mperm[(ii + 1) % mperm.length] +\n                2 * this.orbitoris[setnum]) %\n              this.orbitoris[setnum];\n          }\n        }\n      }\n    }\n    let lastId = new Orbit(iota(24), zeros(24), 1);\n    for (let ii = 0; ii < this.cubiesetnames.length; ii++) {\n      if (setmoves && !setmoves[ii]) {\n        continue;\n      }\n      if (this.orbitoris[ii] === 1 || this.killorientation) {\n        if (perms[ii] === iota(lastId.perm.length)) {\n          if (perms[ii] !== lastId.perm) {\n            lastId = new Orbit(perms[ii], oris[ii], 1);\n          }\n          moveorbits.push(lastId);\n        } else {\n          moveorbits.push(new Orbit(perms[ii], oris[ii], 1));\n        }\n      } else {\n        const no = new Array<number>(oris[ii].length);\n        // convert ksolve oris to our internal ori rep\n        for (let jj = 0; jj < perms[ii].length; jj++) {\n          no[jj] = oris[ii][perms[ii][jj]];\n        }\n        moveorbits.push(new Orbit(perms[ii], no, this.orbitoris[ii]));\n      }\n    }\n    let mv = new Transformation(moveorbits);\n    if (amount !== 1) {\n      mv = mv.mulScalar(amount);\n    }\n    return mv;\n  }\n\n  public getOrbitsDef(fortwisty: boolean): OrbitsDef {\n    // generate a representation of the puzzle\n    const setmoves = [];\n    const setnames: string[] = [];\n    const setdefs: OrbitDef[] = [];\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveset = this.getmovesets(k);\n      const movesetorder = this.movesetorders[k];\n      // check there's no redundancy in moveset.\n      for (let i = 0; i < moveset.length; i += 2) {\n        for (let j = 0; j < i; j += 2) {\n          if (moveset[i] === moveset[j] && moveset[i + 1] === moveset[j + 1]) {\n            throw new Error(\"Redundant moves in moveset.\");\n          }\n        }\n      }\n      const allbits = [];\n      for (let i = 0; i < moveset.length; i += 2) {\n        for (let j = moveset[i][0]; j <= moveset[i][1]; j++) {\n          allbits[j] = 1;\n        }\n      }\n      const axiscmoves = this.cmovesbyslice[k];\n      for (let i = 0; i < axiscmoves.length; i++) {\n        if (allbits[i] !== 1) {\n          continue;\n        }\n        const slicecmoves = axiscmoves[i];\n        for (let j = 0; j < slicecmoves.length; j += 2 * movesetorder) {\n          if (this.skipcubie(slicecmoves[j])) {\n            continue;\n          }\n          const ind = this.cubiesetnums[slicecmoves[j]];\n          setmoves[ind] = 1;\n        }\n      }\n    }\n    for (let i = 0; i < this.cubiesetnames.length; i++) {\n      if (!setmoves[i]) {\n        continue;\n      }\n      setnames.push(this.cubiesetnames[i]);\n      setdefs.push(\n        new OrbitDef(\n          this.cubieords[i],\n          this.killorientation ? 1 : this.orbitoris[i],\n        ),\n      );\n    }\n    const solved: Orbit[] = [];\n    for (let i = 0; i < this.cubiesetnames.length; i++) {\n      if (!setmoves[i]) {\n        continue;\n      }\n      const p = [];\n      const o = [];\n      for (let j = 0; j < this.cubieords[i]; j++) {\n        if (fortwisty) {\n          p.push(j);\n        } else {\n          const cubie = this.cubiesetcubies[i][j];\n          p.push(this.cubievaluemap[cubie]);\n        }\n        o.push(0);\n      }\n      solved.push(\n        new Orbit(p, o, this.killorientation ? 1 : this.orbitoris[i]),\n      );\n    }\n    const movenames: string[] = [];\n    const moves: Transformation[] = [];\n    for (let k = 0; k < this.moveplanesets.length; k++) {\n      const moveplaneset = this.moveplanesets[k];\n      const slices = moveplaneset.length;\n      const moveset = this.getmovesets(k);\n      const movesetgeo = this.movesetgeos[k];\n      for (let i = 0; i < moveset.length; i += 2) {\n        const movebits = moveset[i];\n        const mna = getmovename(movesetgeo, movebits, slices);\n        const movename = mna[0];\n        const inverted = mna[1];\n        if (moveset[i + 1] === 1) {\n          movenames.push(movename);\n        } else {\n          movenames.push(movename + moveset[i + 1]);\n        }\n        const mv = this.getMoveFromBits(\n          movebits,\n          moveset[i + 1],\n          inverted,\n          this.cmovesbyslice[k],\n          setmoves,\n          this.movesetorders[k],\n        );\n        moves.push(mv);\n      }\n    }\n    this.ksolvemovenames = movenames; // hack!\n    let r = new OrbitsDef(\n      setnames,\n      setdefs,\n      new VisibleState(solved),\n      movenames,\n      moves,\n    );\n    if (this.optimize) {\n      r = r.optimize();\n    }\n    if (this.scramble !== 0) {\n      r.scramble(this.scramble);\n    }\n    return r;\n  }\n\n  public getMovesAsPerms(): Perm[] {\n    return this.getOrbitsDef(false).moveops.map((_: Transformation) =>\n      _.toPerm(),\n    );\n  }\n\n  public showcanon(disp: (s: string) => void): void {\n    // show information for canonical move derivation\n    showcanon(this.getOrbitsDef(false), disp);\n  }\n\n  public getsolved(): Perm {\n    // get a solved position\n    const r = [];\n    for (let i = 0; i < this.basefacecount; i++) {\n      for (let j = 0; j < this.stickersperface; j++) {\n        r.push(i);\n      }\n    }\n    return new Perm(r);\n  }\n\n  // Given a rotation description that says to align feature1\n  // with a given vector, and then as much as possible feature2\n  // with another given vector, return a Quaternion that\n  // performs this rotation.\n  public getOrientationRotation(desiredRotation: any[]): Quat {\n    const feature1name = desiredRotation[0];\n    const direction1 = new Quat(\n      0,\n      desiredRotation[1][0],\n      -desiredRotation[1][1],\n      desiredRotation[1][2],\n    );\n    const feature2name = desiredRotation[2];\n    const direction2 = new Quat(\n      0,\n      desiredRotation[3][0],\n      -desiredRotation[3][1],\n      desiredRotation[3][2],\n    );\n    let feature1: Quat | null = null;\n    let feature2: Quat | null = null;\n    const feature1geoname = this.swizzler.unswizzle(feature1name);\n    const feature2geoname = this.swizzler.unswizzle(feature2name);\n    for (const gn of this.geonormals) {\n      if (feature1geoname === gn[1]) {\n        feature1 = gn[0];\n      }\n      if (feature2geoname === gn[1]) {\n        feature2 = gn[0];\n      }\n    }\n    if (!feature1) {\n      throw new Error(\"Could not find feature \" + feature1name);\n    }\n    if (!feature2) {\n      throw new Error(\"Could not find feature \" + feature2name);\n    }\n    const r1 = feature1.pointrotation(direction1);\n    const feature2rot = feature2.rotatepoint(r1);\n    const r2 = feature2rot\n      .unproject(direction1)\n      .pointrotation(direction2.unproject(direction1));\n    return r2.mul(r1);\n  }\n\n  public getInitial3DRotation(): Quat {\n    const basefacecount = this.basefacecount;\n    let rotDesc: any = null;\n    if (this.puzzleOrientation) {\n      rotDesc = this.puzzleOrientation;\n    } else if (this.puzzleOrientations) {\n      rotDesc = this.puzzleOrientations[basefacecount];\n    }\n    // either no option specified or no matching key in\n    // puzzleOrientations.\n    if (!rotDesc) {\n      rotDesc = defaultOrientations()[basefacecount];\n    }\n    if (!rotDesc) {\n      throw new Error(\"No default orientation?\");\n    }\n    return this.getOrientationRotation(rotDesc);\n  }\n\n  public generatesvg(\n    w: number = 800,\n    h: number = 500,\n    trim: number = 10,\n    threed: boolean = false,\n  ): string {\n    // generate svg to interoperate with Lucas twistysim\n    w -= 2 * trim;\n    h -= 2 * trim;\n    function extendedges(a: number[][], n: number): void {\n      let dx = a[1][0] - a[0][0];\n      let dy = a[1][1] - a[0][1];\n      const ang = (2 * Math.PI) / n;\n      const cosa = Math.cos(ang);\n      const sina = Math.sin(ang);\n      for (let i = 2; i < n; i++) {\n        const ndx = dx * cosa + dy * sina;\n        dy = dy * cosa - dx * sina;\n        dx = ndx;\n        a.push([a[i - 1][0] + dx, a[i - 1][1] + dy]);\n      }\n    }\n    // if we don't add this noise to coordinate values, then Safari\n    // doesn't render our polygons correctly.  What a hack.\n    function noise(c: number): number {\n      return c + 0 * (Math.random() - 0.5);\n    }\n    function drawedges(id: string, pts: number[][], color: string): string {\n      return (\n        '<polygon id=\"' +\n        id +\n        '\" class=\"sticker\" style=\"fill: ' +\n        color +\n        '\" points=\"' +\n        pts.map((p) => noise(p[0]) + \" \" + noise(p[1])).join(\" \") +\n        '\"/>\\n'\n      );\n    }\n    // What grips do we need?  if rotations, add all grips.\n    let needvertexgrips = this.addrotations;\n    let neededgegrips = this.addrotations;\n    let needfacegrips = this.addrotations;\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const msg = this.movesetgeos[i];\n      for (let j = 1; j <= 3; j += 2) {\n        if (msg[j] === \"v\") {\n          needvertexgrips = true;\n        }\n        if (msg[j] === \"f\") {\n          needfacegrips = true;\n        }\n        if (msg[j] === \"e\") {\n          neededgegrips = true;\n        }\n      }\n    }\n    // Find a net from a given face count.  Walk it, assuming we locate\n    // the first edge from (0,0) to (1,1) and compute the minimum and\n    // maximum vertex locations from this.  Then do a second walk, and\n    // assign the actual geometry.\n    this.genperms();\n    const boundarygeo = this.getboundarygeometry();\n    const face0 = boundarygeo.facenames[0][0];\n    const polyn = face0.length; // number of vertices; 3, 4, or 5\n    const net = this.net;\n    if (net === null) {\n      throw new Error(\"No net?\");\n    }\n    const edges: any = {};\n    let minx = 0;\n    let miny = 0;\n    let maxx = 1;\n    let maxy = 0;\n    edges[net[0][0]] = [\n      [1, 0],\n      [0, 0],\n    ];\n    extendedges(edges[net[0][0]], polyn);\n    for (let i = 0; i < net.length; i++) {\n      const f0 = net[i][0];\n      if (!edges[f0]) {\n        throw new Error(\"Bad edge description; first edge not connected.\");\n      }\n      for (let j = 1; j < net[i].length; j++) {\n        const f1 = net[i][j];\n        if (f1 === \"\" || edges[f1]) {\n          continue;\n        }\n        edges[f1] = [edges[f0][j % polyn], edges[f0][(j + polyn - 1) % polyn]];\n        extendedges(edges[f1], polyn);\n      }\n    }\n    for (const f in edges) {\n      const es = edges[f];\n      for (let i = 0; i < es.length; i++) {\n        minx = Math.min(minx, es[i][0]);\n        maxx = Math.max(maxx, es[i][0]);\n        miny = Math.min(miny, es[i][1]);\n        maxy = Math.max(maxy, es[i][1]);\n      }\n    }\n    const sc = Math.min(w / (maxx - minx), h / (maxy - miny));\n    const xoff = 0.5 * (w - sc * (maxx + minx));\n    const yoff = 0.5 * (h - sc * (maxy + miny));\n    const geos: any = {};\n    const bg = this.getboundarygeometry();\n    const edges2: any = {};\n    const initv = [\n      [sc + xoff, yoff],\n      [xoff, yoff],\n    ];\n    edges2[net[0][0]] = initv;\n    extendedges(edges2[net[0][0]], polyn);\n    geos[this.facenames[0][1]] = this.project2d(0, 0, [\n      new Quat(0, initv[0][0], initv[0][1], 0),\n      new Quat(0, initv[1][0], initv[1][1], 0),\n    ]);\n    const connectat = [];\n    connectat[0] = 0;\n    for (let i = 0; i < net.length; i++) {\n      const f0 = net[i][0];\n      if (!edges2[f0]) {\n        throw new Error(\"Bad edge description; first edge not connected.\");\n      }\n      let gfi = -1;\n      for (let j = 0; j < bg.facenames.length; j++) {\n        if (f0 === bg.facenames[j][1]) {\n          gfi = j;\n          break;\n        }\n      }\n      if (gfi < 0) {\n        throw new Error(\"Could not find first face name \" + f0);\n      }\n      const thisface = bg.facenames[gfi][0];\n      for (let j = 1; j < net[i].length; j++) {\n        const f1 = net[i][j];\n        if (f1 === \"\" || edges2[f1]) {\n          continue;\n        }\n        edges2[f1] = [\n          edges2[f0][j % polyn],\n          edges2[f0][(j + polyn - 1) % polyn],\n        ];\n        extendedges(edges2[f1], polyn);\n        // what edge are we at?\n        const caf0 = connectat[gfi];\n        const mp = thisface[(caf0 + j) % polyn]\n          .sum(thisface[(caf0 + j + polyn - 1) % polyn])\n          .smul(0.5);\n        const epi = findelement(bg.edgenames, mp);\n        const edgename = bg.edgenames[epi][1];\n        const el = splitByFaceNames(edgename, this.facenames);\n        const gf1 = el[f0 === el[0] ? 1 : 0];\n        let gf1i = -1;\n        for (let k = 0; k < bg.facenames.length; k++) {\n          if (gf1 === bg.facenames[k][1]) {\n            gf1i = k;\n            break;\n          }\n        }\n        if (gf1i < 0) {\n          throw new Error(\"Could not find second face name\");\n        }\n        const otherface = bg.facenames[gf1i][0];\n        for (let k = 0; k < otherface.length; k++) {\n          const mp2 = otherface[k].sum(otherface[(k + 1) % polyn]).smul(0.5);\n          if (mp2.dist(mp) <= eps) {\n            const p1 = edges2[f0][(j + polyn - 1) % polyn];\n            const p2 = edges2[f0][j % polyn];\n            connectat[gf1i] = k;\n            geos[gf1] = this.project2d(gf1i, k, [\n              new Quat(0, p2[0], p2[1], 0),\n              new Quat(0, p1[0], p1[1], 0),\n            ]);\n            break;\n          }\n        }\n      }\n    }\n    // Let's build arrays for faster rendering.  We want to map from geo\n    // base face number to color, and we want to map from geo face number\n    // to 2D geometry.  These can be reused as long as the puzzle overall\n    // orientation and canvas size remains unchanged.\n    const pos = this.getsolved();\n    const colormap = [];\n    const facegeo = [];\n    for (let i = 0; i < this.basefacecount; i++) {\n      colormap[i] = this.colors[this.facenames[i][1]];\n    }\n    let hix = 0;\n    let hiy = 0;\n    const rot = this.getInitial3DRotation();\n    for (let i = 0; i < this.faces.length; i++) {\n      let face = this.faces[i];\n      face = rot.rotateface(face);\n      for (let j = 0; j < face.length; j++) {\n        hix = Math.max(hix, Math.abs(face[j].b));\n        hiy = Math.max(hiy, Math.abs(face[j].c));\n      }\n    }\n    const sc2 = Math.min(h / hiy / 2, (w - trim) / hix / 4);\n    const mappt2d = (fn: number, q: Quat): number[] => {\n      if (threed) {\n        const xoff2 = 0.5 * trim + 0.25 * w;\n        const xmul = this.baseplanes[fn].rotateplane(rot).d < 0 ? 1 : -1;\n        return [\n          trim + w * 0.5 + xmul * (xoff2 - q.b * sc2),\n          trim + h * 0.5 + q.c * sc2,\n        ];\n      } else {\n        const g = geos[this.facenames[fn][1]];\n        return [trim + q.dot(g[0]) + g[2].b, trim + h - q.dot(g[1]) - g[2].c];\n      }\n    };\n    for (let i = 0; i < this.faces.length; i++) {\n      let face = this.faces[i];\n      const facenum = Math.floor(i / this.stickersperface);\n      if (threed) {\n        face = rot.rotateface(face);\n      }\n      facegeo.push(face.map((_: Quat) => mappt2d(facenum, _)));\n    }\n    const svg = [];\n    // group each base face so we can add a hover element\n    for (let j = 0; j < this.basefacecount; j++) {\n      svg.push(\"<g>\");\n      svg.push(\"<title>\" + this.facenames[j][1] + \"</title>\\n\");\n      for (let ii = 0; ii < this.stickersperface; ii++) {\n        const i = j * this.stickersperface + ii;\n        const cubie = this.facetocubies[i][0];\n        const cubieori = this.facetocubies[i][1];\n        const cubiesetnum = this.cubiesetnums[cubie];\n        const cubieord = this.cubieordnums[cubie];\n        const color = this.graybyori(cubie) ? \"#808080\" : colormap[pos.p[i]];\n        let id =\n          this.cubiesetnames[cubiesetnum] + \"-l\" + cubieord + \"-o\" + cubieori;\n        svg.push(drawedges(id, facegeo[i], color));\n        if (this.duplicatedFaces[i]) {\n          for (let jj = 1; jj < this.duplicatedFaces[i]; jj++) {\n            id = this.cubiesetnames[cubiesetnum] + \"-l\" + cubieord + \"-o\" + jj;\n            svg.push(drawedges(id, facegeo[i], color));\n          }\n        }\n      }\n      svg.push(\"</g>\");\n    }\n    const svggrips: any[] = [];\n    function addgrip(\n      onface: number,\n      name: string,\n      pt: Quat,\n      order: number,\n    ): void {\n      const pt2 = mappt2d(onface, pt);\n      for (let i = 0; i < svggrips.length; i++) {\n        if (\n          Math.hypot(pt2[0] - svggrips[i][0], pt2[1] - svggrips[i][1]) < eps\n        ) {\n          return;\n        }\n      }\n      svggrips.push([pt2[0], pt2[1], name, order]);\n    }\n    for (let i = 0; i < this.faceplanes.length; i++) {\n      const baseface = this.facenames[i][0];\n      let facecoords = baseface;\n      if (threed) {\n        facecoords = rot.rotateface(facecoords);\n      }\n      if (needfacegrips) {\n        let pt = this.faceplanes[i][0];\n        if (threed) {\n          pt = pt.rotatepoint(rot);\n        }\n        addgrip(i, this.faceplanes[i][1], pt, polyn);\n      }\n      for (let j = 0; j < baseface.length; j++) {\n        if (neededgegrips) {\n          const mp = baseface[j]\n            .sum(baseface[(j + 1) % baseface.length])\n            .smul(0.5);\n          const ep = findelement(this.edgenames, mp);\n          const mpc = facecoords[j]\n            .sum(facecoords[(j + 1) % baseface.length])\n            .smul(0.5);\n          addgrip(i, this.edgenames[ep][1], mpc, 2);\n        }\n        if (needvertexgrips) {\n          const vp = findelement(this.vertexnames, baseface[j]);\n          addgrip(i, this.vertexnames[vp][1], facecoords[j], this.cornerfaces);\n        }\n      }\n    }\n    const html =\n      '<svg id=\"svg\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 800 500\">\\n' +\n      '<style type=\"text/css\"><![CDATA[' +\n      \".sticker { stroke: #000000; stroke-width: 1px; }\" +\n      \"]]></style>\\n\" +\n      svg.join(\"\") +\n      \"</svg>\";\n    this.svggrips = svggrips;\n    return html;\n  }\n\n  public dist(a: number[], b: number[]): number {\n    return Math.hypot(a[0] - b[0], a[1] - b[1], a[2] - b[2]);\n  }\n\n  public triarea(a: number[], b: number[], c: number[]): number {\n    const ab = this.dist(a, b);\n    const bc = this.dist(b, c);\n    const ac = this.dist(a, c);\n    const p = (ab + bc + ac) / 2;\n    return Math.sqrt(p * (p - ab) * (p - bc) * (p - ac));\n  }\n\n  public polyarea(coords: number[][]): number {\n    let sum = 0;\n    for (let i = 2; i < coords.length; i++) {\n      sum += this.triarea(coords[0], coords[1], coords[i]);\n    }\n    return sum;\n  }\n\n  // The colorfrac parameter says how much of the face should be\n  // colored (vs dividing lines); we default to 0.77 which seems\n  // to work pretty well.  It should be a number between probably\n  // 0.4 and 0.9.\n  public get3d(\n    colorfrac: number = DEFAULT_COLOR_FRACTION,\n    options?: {\n      stickerColors?: string[];\n    },\n  ): StickerDat {\n    const stickers: any = [];\n    const foundations: any = [];\n    const rot = this.getInitial3DRotation();\n    const faces: any = [];\n    const maxdist: number = 0.52 * this.basefaces[0][0].len();\n    let avgstickerarea = 0;\n    for (let i = 0; i < this.basefaces.length; i++) {\n      const coords = rot.rotateface(this.basefaces[i]);\n      const name = this.facenames[i][1];\n      faces.push({ coords: toFaceCoords(coords, maxdist), name });\n      avgstickerarea += this.polyarea(faces[i].coords);\n    }\n    avgstickerarea /= this.faces.length;\n    const trim = (Math.sqrt(avgstickerarea) * (1 - Math.sqrt(colorfrac))) / 2;\n    for (let i = 0; i < this.faces.length; i++) {\n      const facenum = Math.floor(i / this.stickersperface);\n      const cubie = this.facetocubies[i][0];\n      const cubieori = this.facetocubies[i][1];\n      const cubiesetnum = this.cubiesetnums[cubie];\n      const cubieord = this.cubieordnums[cubie];\n      let color = this.graybyori(cubie)\n        ? \"#808080\"\n        : this.colors[this.facenames[facenum][1]];\n      if (options?.stickerColors) {\n        color = options.stickerColors[i];\n      }\n      let coords = rot.rotateface(this.faces[i]);\n      foundations.push({\n        coords: toFaceCoords(coords, maxdist),\n        color,\n        orbit: this.cubiesetnames[cubiesetnum],\n        ord: cubieord,\n        ori: cubieori,\n      });\n      const fcoords = coords;\n      if (trim && trim > 0) {\n        coords = trimEdges(coords, trim);\n      }\n      stickers.push({\n        coords: toFaceCoords(coords, maxdist),\n        color,\n        orbit: this.cubiesetnames[cubiesetnum],\n        ord: cubieord,\n        ori: cubieori,\n      });\n      if (this.duplicatedFaces[i]) {\n        for (let jj = 1; jj < this.duplicatedFaces[i]; jj++) {\n          stickers.push({\n            coords: toFaceCoords(coords, maxdist),\n            color,\n            orbit: this.cubiesetnames[cubiesetnum],\n            ord: cubieord,\n            ori: jj,\n          });\n          foundations.push({\n            coords: toFaceCoords(fcoords, maxdist),\n            color,\n            orbit: this.cubiesetnames[cubiesetnum],\n            ord: cubieord,\n            ori: jj,\n          });\n        }\n      }\n    }\n    const grips: StickerDatAxis[] = [];\n    for (let i = 0; i < this.movesetgeos.length; i++) {\n      const msg = this.movesetgeos[i];\n      const order = this.movesetorders[i];\n      for (let j = 0; j < this.geonormals.length; j++) {\n        const gn = this.geonormals[j];\n        if (msg[0] === gn[1] && msg[1] === gn[2]) {\n          grips.push([toCoords(gn[0].rotatepoint(rot), 1), msg[0], order]);\n          grips.push([\n            toCoords(gn[0].rotatepoint(rot).smul(-1), 1),\n            msg[2],\n            order,\n          ]);\n        }\n      }\n    }\n    const f = (function () {\n      return function (mv: Move): string {\n        return this.unswizzle(mv);\n      };\n    })().bind(this);\n    return {\n      stickers,\n      foundations,\n      faces,\n      axis: grips,\n      unswizzle: f,\n      notationMapper: this.notationMapper,\n    };\n  }\n\n  //  From the name of a geometric element (face, vertex, edge), get a\n  //  normal vector respecting the default orientation.  This is useful\n  //  to define the initial position of the camera in a 3D scene.  The\n  //  return value is normalized, so multiply it by the camera distance.\n  //  Returns undefined if no such geometric element.\n  public getGeoNormal(geoname: string): number[] | undefined {\n    const rot = this.getInitial3DRotation();\n    const grip = this.swizzler.unswizzle(geoname);\n    for (let j = 0; j < this.geonormals.length; j++) {\n      const gn = this.geonormals[j];\n      if (grip === gn[1]) {\n        const r = toCoords(gn[0].rotatepoint(rot), 1);\n        //  This routine is intended to use for the camera location.\n        //  If the camera location is vertical, and we give some\n        //  near-zero values for x and z, then the rotation in the\n        //  X/Z plane will be somewhat arbitrary.  So we clean up the\n        //  returned vector here.  We give a very slight positive\n        //  z value.\n        if (Math.abs(r[0]) < eps && Math.abs(r[2]) < eps) {\n          r[0] = 0.0;\n          r[2] = 1e-6;\n        }\n        return r;\n      }\n    }\n    return undefined;\n  }\n\n  private getfaceindex(facenum: number): number {\n    const divid = this.stickersperface;\n    return Math.floor(facenum / divid);\n  }\n}\n\nclass PGNotation implements MoveNotation {\n  private cache: { [key: string]: KTransformation } = {};\n  public orbitNames: string[];\n  constructor(public pg: PuzzleGeometry, od: OrbitsDef) {\n    this.orbitNames = od.orbitnames;\n  }\n\n  public lookupMove(move: Move): KTransformation | undefined {\n    const key = this.moveToKeyString(move);\n    if (key in this.cache) {\n      return this.cache[key];\n    }\n    const mv = this.pg.parseMove(move);\n    let bits = [mv[2], mv[3]];\n    if (!mv[4]) {\n      const slices = this.pg.moveplanesets[mv[1]].length;\n      bits = [slices - mv[3], slices - mv[2]];\n    }\n    const pgmv = this.pg.getMoveFromBits(\n      bits,\n      mv[5],\n      !mv[4],\n      this.pg.cmovesbyslice[mv[1]],\n      undefined,\n      this.pg.movesetorders[mv[1]],\n    );\n    const r = OrbitsDef.transformToKPuzzle(this.orbitNames, pgmv);\n    this.cache[key] = r;\n    return r;\n  }\n\n  // This is only used to construct keys, so does not need to be beautiful.\n  private moveToKeyString(move: Move): string {\n    let r = \"\";\n    if (move.outerLayer) {\n      r = r + move.outerLayer + \",\";\n    }\n    if (move.innerLayer) {\n      r = r + move.innerLayer + \",\";\n    }\n    r = r + move.family + \",\" + move.effectiveAmount;\n    return r;\n  }\n}\n","import { identity, Perm } from \"./Perm\";\n\nclass FactoredNumber {\n  public mult: number[];\n  constructor() {\n    this.mult = [];\n  }\n\n  public multiply(n: number): void {\n    for (let f = 2; f * f <= n; f++) {\n      while (n % f === 0) {\n        if (undefined !== this.mult[f]) {\n          this.mult[f]++;\n        } else {\n          this.mult[f] = 1;\n        }\n        n /= f;\n      }\n    }\n    if (n > 1) {\n      if (undefined !== this.mult[n]) {\n        this.mult[n]++;\n      } else {\n        this.mult[n] = 1;\n      }\n    }\n  }\n\n  public toString(): string {\n    let r = \"\";\n    for (let i = 0; i < this.mult.length; i++) {\n      if (undefined !== this.mult[i]) {\n        if (r !== \"\") {\n          r += \"*\";\n        }\n        r += i;\n        if (this.mult[i] > 1) {\n          r += \"^\" + this.mult[i];\n        }\n      }\n    }\n    return r;\n  }\n}\n\nexport function schreierSims(g: Perm[], disp: (s: string) => void): number {\n  const n = g[0].p.length;\n  const e = identity(n);\n  let sgs: Perm[][] = [];\n  let sgsi: Perm[][] = [];\n  let sgslen: number[][] = [];\n  let Tk: Perm[][] = [];\n  let Tklen: number[][] = [];\n  function resolve(p: Perm): boolean {\n    for (let i = p.p.length - 1; i >= 0; i--) {\n      const j = p.p[i];\n      if (j !== i) {\n        if (!sgs[i][j]) {\n          return false;\n        }\n        p = p.mul(sgsi[i][j]);\n      }\n    }\n    return true;\n  }\n  function knutha(k: number, p: Perm, len: number): void {\n    Tk[k].push(p);\n    Tklen[k].push(len);\n    for (let i = 0; i < sgs[k].length; i++) {\n      if (sgs[k][i]) {\n        knuthb(k, sgs[k][i].mul(p), len + sgslen[k][i]);\n      }\n    }\n  }\n  function knuthb(k: number, p: Perm, len: number): void {\n    const j = p.p[k];\n    if (!sgs[k][j]) {\n      sgs[k][j] = p;\n      sgsi[k][j] = p.inv();\n      sgslen[k][j] = len;\n      for (let i = 0; i < Tk[k].length; i++) {\n        knuthb(k, p.mul(Tk[k][i]), len + Tklen[k][i]);\n      }\n      return;\n    }\n    const p2 = p.mul(sgsi[k][j]);\n    if (!resolve(p2)) {\n      knutha(k - 1, p2, len + sgslen[k][j]);\n    }\n  }\n  function getsgs(): number {\n    sgs = [];\n    sgsi = [];\n    Tk = [];\n    sgslen = [];\n    Tklen = [];\n    for (let i = 0; i < n; i++) {\n      sgs.push([]);\n      sgsi.push([]);\n      sgslen.push([]);\n      Tk.push([]);\n      Tklen.push([]);\n      sgs[i][i] = e;\n      sgsi[i][i] = e;\n      sgslen[i][i] = 0;\n    }\n    let none = 0;\n    let sz = 1;\n    for (let i = 0; i < g.length; i++) {\n      knutha(n - 1, g[i], 1);\n      sz = 1;\n      let tks = 0;\n      let sollen = 0;\n      const avgs = [];\n      const mults = new FactoredNumber();\n      for (let j = 0; j < n; j++) {\n        let cnt = 0;\n        let lensum = 0;\n        for (let k = 0; k < n; k++) {\n          if (sgs[j][k]) {\n            cnt++;\n            lensum += sgslen[j][k];\n            if (j !== k) {\n              none++;\n            }\n          }\n        }\n        tks += Tk[j].length;\n        sz *= cnt;\n        if (cnt > 1) {\n          mults.multiply(cnt);\n        }\n        const avg = lensum / cnt;\n        avgs.push(avg);\n        sollen += avg;\n      }\n      disp(\n        \"\" +\n          i +\n          \": sz \" +\n          sz +\n          \" T \" +\n          tks +\n          \" sol \" +\n          sollen +\n          \" none \" +\n          none +\n          \" mults \" +\n          mults,\n      );\n    }\n    return sz;\n  }\n  return getsgs();\n}\n"],"sourceRoot":""}